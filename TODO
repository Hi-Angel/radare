
  ___________ _____  ______   _____
  \___   ___/ _==_ \'   ._ \/ _==_ \
    \'   '//        \   '   \       \  for radare
     \___/ \________/.______/_______/


===========================================================

(gdb) break ptrace if $r3 == 31
make fdsniff and usbsniff generate a project file and a binary one.

  fdsniff3.bin
open filedescriptors

BUGS:
=====
* :po shows ascii bytes?!?!? should work like pX does..or :px should do (pX removed)
* xc can get_math!
* cmd.flag = eip -> fer una taula de offsets-comandes per cmd.flag
  - fc = flag command fc <command> @ offset
  - do not execute twice
* Load lua scripts from commandline
* allow to run without opening a file (useful for batch mode)
* zoom segfaults
* winedbg doesnt reads the unalligned memory properly FIX IT!
* keybinding assignment dosnt workz
* java disasm is borken (seek problemz?!?!)
* wa doesnt handle file resize
* cursor doesnt works in w32 console ??
* rsc monitor doesnt works as expected
* threading stuff for ptrace is broken. try to make the ada crackme
  http://crackmes.de/users/darkphoenix_/ada_crackme_1_elf/
* inv -> make offsets take sense
  - make cursor bytes take sense too
* s <unexistant-flag> -> do not seek
* !ret should use !bt if possible
* In visual mode the 'w' doesn't allows to erase chars (backspace..)
   - pipecmd2str must use radare_cmd_str
* new graph view
  * string references are referenced to a block which is composed by jumps (a calls or ret break a block)
* import esteve's object injector
* winedbg !cont
  help                                   quit
  break [*<addr>]                        watch *<addr>
  delete break bpnum                     disable bpnum
  enable bpnum                           condition <bpnum> [<expr>]
  finish                                 cont [N]
  step [N]                               next [N]
  stepi [N]                              nexti [N]
  x <addr>                               print <expr>
  display <expr>                         undisplay <disnum>
  local display <expr>                   delete display <disnum>
  enable display <disnum>                disable display <disnum>
  bt [<tid>|all]                         frame <n>
  up                                     down
  list <lines>                           disassemble [<addr>][,<addr>]
  show dir                               dir <path>
  set <reg> = <expr>                     set *<addr> = <expr>
  pass                                   whatis
  info (see 'help info' for options)

* next pel debugger (next source line) -- comment uh?
* handle !! properly
!signal has no help :O
* status shows backtrace !?!?!

TODO for 0.9.4
==============
* Indentify, parse and show the auxv_t structure
* pA must show decimal value too
* wtf 'undo' command shows the fking list of steps?
  - must be silent
* avoid dupped (NULL's) in pA command (cleaner to read)
* filter visible flags with scr.flagfilter (strstr expression)
* make !dump incremental
  - support to enable full dump (with hashing for reducing sizes)
  - bindiffing
  - ultra slow ? i should analyze code to enhace this
* code data type must be saved and loaded in project
* bindiff is buggy (gnu huh!)
  - use bdiff
  - integrated with bdcolor huh!
* support to append data (without getting out of the block_size) (or so..)
* Lua API
* Fixed udis loop
  - colorize opcodes by arch_aop
* cfg.invdelta = inverses the delta (<=1024 ..-> >=1024) (or delta range) deltamin deltamax
* dump file to filedescriptor of the child doesnt works (child.stdin)
* identify nodes with 'ret' in graph
* identify nodes with 'cmp' in graph
* A key to increase/decrease the byte value under the cursor
* udis disassembly is a bit weird with values + and -
  - makes the reading a bit difficult (if higher bit set, use negative value)
  f.example:
      0x0804D169  8985f0fdffff      [ebp-0x210] = eax
      0x0804D16F  8d85f4fdffff      lea eax, [ebp+0xfffffdf4] ; should be -524
* implement insert data inda core
* graph.body=asm,flags,symcalls,description, trace execution data
* blue or black background for metadata in udis -> nicer for w32 and white screens
  - use global palete in eval variable
  - scr.palete = 1732367 -> when printing colors are peeked from this palete
* Create linked list of hit0[0] and hit1[0] , etc..
  define block size by hit1[0]-hit0[0]
* remove comments with cursor


TODO for 0.9.5
==============
* StreamViewer
* invert pel disasm
* /a algorithm defined by search.algorithm
 it flags if search.flag
  - armfuncsearch
  - aes
  - token [from] [to] (dinamic block size)
  - x86funcsearch
  - from file formatted as search db
  - carver (find from-to,maxlen, ...)
  - plugin
* RDBs stored into Projects
  project.rdb = false ; store or not
  use [delimiters] to embed rdbs inside rps
* MSB stego

Rabin
=====
* elf-section-headers -> loggejar shelf stuff
  - pillar base address al vol ( rabin -b)
* add full PE support to rabin
* integrated with radare debugger /code analyer
* Move radare -S into rabin to find strings in data sections only
  - like gnu strings like bfd does

Open streams
============
* as io plugin?
* config.stream=1
$ radare /dev/ttyS0
* should also work for network sockets or unix ones
  socket.c must be updated!
* configure bps and so
* code block is filled progressively with bytes
  readed from the filedescriptor
* write command is used
* needs new interactive mode ala minicom
* useful for filedescriptor of child processes
* also for sniffing
* somewhat like an always-growing file :)
* autoscrolling to the end for interactive visual


* print disasembly by trace from an starting address
  * roll/funroll code
  - pD 100 | sort
  - true jumps are done, false ones are ignored
  - stacked disassembly (like vim folders)

* dbg.vstepkey = step or stepu, chooses the 's' action.
  - step over non-user code?
  - block descriptor (if regs traced, or so show info)
* add scr.cursor scr.cursor_range evals

+ EH - event handling (event type + source pid)
  using linked list.h
  * add '!eh' command, how to handle an event ((ignore?), log, bypass, handle)

* allow to specify what you want to see when tracing (cmd.cmttrace) ?
  - is not oneliner
  - analyze these comments to identify loop variables and so

Graphs
======
  - show comments in a separated toggleable box:

   +-------------+
   | 0x0804483   |-----------.
   +-------------+           |
   | mov eax, 3  | sys_write |
   | int 0x80    |           |
   +-------------+-----------'

  - line clicking must be supported!
  - avoid out of context bytes

* tracecc
  - useful to walk to user code
  - copy the program code on another buffer
  - overwrite all code with 0xcc
  - not portable, coz arm mixes data and code
  - continue until breakpoints
* virtual machine decompilation -> helpers for debugging soft VM opcodes (new user-defined archs)
* analize input/output of function calls
  - bp enter
  - bp exit
  - useful to reverse packer VMs
  - see what changes in register and memory


* Show FPU stack contents

* exception frame information (try { ... } catch stuff)
* ram dump driver for w32

* switch table decompilation
* implement bindiff in the core
  - Allow to bindiff two data blocks or repeated data blocks (src,dst,len)
  - use the pattern finding algorithm
* dinamic block size defined by:
  - height of screen
  - <tags> (set inigial and end binary tags)
    - allow to move forward/backward between 'bintags'
* wtrace
  - rename to stepw
  - trace using !wp or so? wtrace until reached wp?
* cfg.dbgbsize (default block size for debugger)
* breakpoints
  - command
  - log (trace)
  - enabled
* RDB TO GML
* circle to group looped code blocks in graph view
* trace.libcode = trace libcode or not?
  - automatic stepu 

* support size of pointer with [xxx] get_offset expressions
  - b[xxx], w[xxx], d[xxx], 32[xxx], 16[xxx], 8[xxx]
  - also make use of cfg.endian

---------------------------
* do not sigalarm in visual
* new flag type: temporal 
  - they will not survive a project save
  - they are destroyed after a timeout

w32 Debugger
============
* implement !maps
* pid:// doesn't works


Search
======
 * search for head and foot
  - for each head finds a foot and defines block size
* Fix search progress bar and hits view (cleaner :!!)
  - output configure by search.
* new search engine allowing AES and RSA key (so...predefined algos for signature searches)
  - must think on! - entropia = 1 en un block (tots numeros primers)

Filesystem
==========
* emulate filesystems from a defined seek
* can be done with losetup? not portable
* use fuse emulation?
* use linux kernel emulation?
* shell with grub-like commands to extract and insert files?

Core
====
* function hooker in C (dbg.hooker)      
  - some C macros or so to create a .so and LD_PRELOAD't
  - if static...should inject trampolines to our code.
* add cfg.insert (make user write operations insert or overwrite)
* Multiple rdb load
  - allow to map into flags, etc..
* optimized flag storing algorithm (a bit slower for >5000 strings)
  * flag namespaces (comment, label, symbol, ...) sym. cmt. ...
  * marcar blocks amb cursor i asignar un alias o nom (flag)
    - flags must have start and end
    - flags/comments/labels/dwarf
    - optimized linked list usage
* Add views/states/.. (S (switch) command) (open multiple files)
  - A view is just a stored copy of the config_t structure
  - and store different states for the same file
  - think on how to allocate new states (linked list of config_t structs)
  - S
    0 /bin/ls 0x0000000 ; comment
    1 /bin/ls 0x0000123 ; comment2
  - S [number]

Rasm
====
* Add .db, .byte, .dw, .dd directives or so, .string
  - make them usable from the assembler (labels and so too)
* -f, load opcodes from file
* add directives
* Must ignore stuff after ';'

Visual
======
* colorize background of flagged bytes in hexdump
* ease monitor access from the visual (xterm or so) (run inside dvtm?)
* count the number of lines in backtrace and substract them to make the visual
* add scrolling acceleration. (cfg.accel or so)

Hasher
======
* Refactor code -> no dupped code
  - sum*charpos, hash sha0, md2, crc64, hmac, network-hashes

Tracer
======
* store more info in trace (output of command)
* random trace peeker
  - takes traces from the process while running every N usecs
* timeline of a trace |----------------|
  - allow to view frame windows inside the timeline
  - extended 'f' and 'F' keys mode
  * List viewer (get offset as index fr cursor, right view shows the
    contents of th selected offset
    - linked list browser
* cmd.trace -> command to execute when tracing
  - trace.log should be parsed insiide radare visual
    (next/next-->prev...)
  - trace extra regs info: (show bytes where they point)
    eax 0x8048484 bytes...
  - blank line means a trace step
  - program_t -> asign name and color
    -> useful to merge graphs of code analysis and code execution
  - if comments have a '{' indent disasemly to the right and '}' to the left
  - allow to monitor register values and memory pointers
    - for example:
     > :x 200 @ [eax]+33
  - flag monitring
* tracepoints
  - allow to execute a command (!dump?)
    - follow some variables
* colorize traces in vala graphs
* trace graph
  - debug.c -> implement a while(debug_step()) loop to arch_aop() each instruction
    and draw a graph until a breakpoint or ^C
  - creates a program_t graphable with vala
  - can be diffed with rdbdiff

FileDescriptors
===============
* read/write from/to child filedescriptor
* sniff filedescriptor (dumping to file or socket)

Debugger
========
* trace on !wp
* al atacharse a un proces deixa <pid>.rdb hauria de ser <program.pid>.rdb?
* debug_new() -> alloc new glib object or so
  - allows multiple ps structures to be loaded
  - needs refactoring?
    - maybe only change a pointer. setCurrentProcess() or so

	Debugger d = new Debugger("/bin/ls");
	Debugger d2 = new Debugger("/bin/true");
	d.setCurrentProcess();
	d.breakpoint(0x8048930);
	d.continue();

* code injector for accessing non GP registers like mmx,
   fp, etc and other's section segments. (%ss, ..)
  off_t value = get_reg_inline("m0");
  - store a struct containing 
	char * register_name;
	uchar *shellcode
  - all shellcodes must be coded and injected in the same way
* show esp-ebp !!! stackframe is important everywhere! ??
* show esp-ebp of stack at top (or mark a range)
  - show stack offsets
  - max size of stack
  - colorize esb-ebp with temp cursor or so
* implement process freze and bootup
* own elf loader (avoid system one)
* amd64 -> x86-64 -> alias ( BSD64 is broken )
* load libraries on the child process
* breakpoint callbacks:
 - integrated with !wp too
  A hook to an api can be emulated from the debugger, no need to inject
  code everywhere, just BP and change regs
* add dosdebug:// to debug dosemu-based applications
* import of qemu:// plugin to connect to qemus :D
 - ptrace layer make't support syscall proxying for remote debugging!!1 rasc -l rulez
* use 'tm' (terminal mixer) to run the target debugged program
   - allows multiple interactives consoles over the program,
     keeping the debugger window clean
   - we need to know the pid of the child process of tm.
   - maybe a debug flag to tm would be nice - i will talk to the author
   - must be hardcoded inside the core
 - handle ^C properly , to allow to stop the process with any signal
* make libgdb2fd work
* Allow to run shellcodes on debugged process.
  (autodetect .s or raw binary)
  - read shellcode from a file 
    should support .c or .s or raw or elf _start

Code analyzer
=============
* handle relative references to code and data
* Implement libcaca/aalib backend for grava! :D
* xrefs does not works for string references
  - make xrefs support base address
  - integrate xrefs into the core (debugger needs love too!)
  [ xref struct ] ; basic jump table
   - u64 from
   - u64 to   -> nothing more :)
  - only for valid analyzed code .. uh?
  - data xrefs is not detected here. uh?
* persistent nodes in graph executing commands

Gui
===
* Implement 'gui hack' command for 'GUI plugins'.
  - implement start/pause/continue/stop/reload button for a pid
* frontend for hasher (Vala api for hashing)
* GUI: contextual popup menu allows to change font size
* the gui must listen:// and connect:// too!
* Add toggle endian in gradare
* integrate the gui with maemo!

Random
======
* Update manpages
* output of rsc help should start with ';'
* Implement a boolean bindiff based on symdiffing (uses dwarf)
* make monitors work with inotify and glib events or so


===========================================================

TOTHINK
=======
* Do not use the char '(' in asm.lines. just use - or =
* record radare commands
  - all commands executed within a recording time are stored on a single script file
  - you can later repeat it or edit
* mode2 for keybinding numbers for jmp/calls
  - only if jump out of view
* '<' and '>' commands converted in prefix modifiers
* executable offsets
  - execute a command on a certain offset
  - show funtion frames and arguments on the fly
  - automatize unpacks and so

* performance counters:
   - inject code into the child process
   - mmap to backup code from the hooked functions
   - each hooked function should do something like:
       [mmap_addr+func_off]++;
   - these counters can be resetted
   - the mmap is only defined once
   - show statistics of time range and the count of times a function
     has been called.
 - timers:
   - inject code into the child process to define from-to zones
   - these from-to zones have an mmap address assigned
   - uses rdtsc to get time

	// 'from' hook
     push eax
     rdtsc
     mov [mmap_addr+my_func], eax
     pop eax

	// 'to' hook
     push eax
     rdtsc
     mov [mmap_addr+my_func+4], eax
     pop eax

   - statistics will show the time spend to run a determined piece of code

* implement move data inside the core (yank?)
 - add software watchpoints with stepall (register and memory changes control)
 - fer un binpatch a traves del contexte del asm que sigui muahah
 - rasc : send file and execute (pitbull inside!)
  - use it for the fuzzer framework

* DWARF DUMP !!! 
  * add 'list' gdb -like command
  * http://reality.sgiweb.org/davea/dwarf.html

BSD_SYSCALL_PTRACE:
===================

.global foo
foo:
        mov $2, %ebx
        mov $1, %eax
        push %ebx
        push %eax
        int $0x80


libraries
=========
libsal   -> implements a layer on top of radare for SAL (or parrot?) (or nekovm?)
libiconv -> encoding support
libmagic -> better integration with magic stuff (atm use external magic dbs) (obsd magic)
libdwarf -> supports dwarf stuff and so


TODO LIST
=========
* ._ command not supported .. ? of course not!
* use #pragma once?
* bash autocompletion script for rsc and rfile
* base64 conversion, fixer and so
* full charsets support (search strings in utf8, etc)
* implement 'commit' command. delayed write operations with bindiff output
* undo write and more things

* total world domination
