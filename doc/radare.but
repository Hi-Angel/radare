\cfg{paper-code-font-size}{9}
\cfg{paper-code-fonts}{Courier}{Courier}{Courier}

\title radare

A commandline framework for reverse engineering ala *nix-style

\versionid $Id: pvc.but 2008-09-02 pancake $

\C{introduction} Introduction

The radare project started in February of 2006 aiming to provide a Free and simple command line interface for an hexadecimal editor supporting 64 bit offsets to make searches and recovering data from hard-disks.

Since then, the project has grown with the aim changed to provide a complete framework for analyzing binaries with some basic *NIX concepts in mind like 'everything is a file', 'small programs that interact together using stdin/out' or 'keep it simple'.

It's mostly a single-person project, but some contributions (in source, patches, ideas or species) have been made and are really appreciated.

The project is composed by an hexadecimal editor as the central point of the project with assembler/disassembler, code analysis, scripting features, analysis and graphs of code and data, easy unix integration, ..

\H{overview} Overview

Nowadays the project is composed by a set of small utilities that can be used together or independently from the command line:

\c radare

The core of the hexadecimal editor and debugger. Allows to open any kind of file from different IO access like disk, network, kernel plugins, remote devices, debugged processes, ... and handle any of them as if they were a simple plain file.

Implements an advanced command line interface for moving around the file, analyzing data, disassembling, binary patching, data comparision, searching, replacing, scripting with python, lua and perl, ...

\c rabin

Extracts information from executable binaries like ELF, PE, Java CLASS, MACH-O. It's used from the core to get exported symbols, imports, file information, xrefs, library dependencies, sections, ...

\c rasm

Commandline assembler and disassembler for multiple architectures (intel[32,64], mips, arm, powerpc, java, msil, ...)

\c $ rasm -a java 'nop'
\c 00
\c $ rasm -a x86 -d '90'
\c nop

\c rasc

Small utility to prepare buffers or shellcodes for exploiting vulnerabilities. It has an internal hardcoded database of shellcodes and a syscall-proxy interface with some nice helpers like fill-with nops, breakpoints, series of values to find the landing point, etc..

\c hasher

Implementation of a block-based hasher for small text strings or large disks, supporting multiple algorithms like md4, md5, crc16, crc32, sha1, sha256, sha384, sha512, par, xor, xorpair, mod255, hamdist or entropy.

It can be used to check the integrity or track changes between big files, memory dumps or disks.

\c radiff

Binary diffing utility with multiple algorithms implemented inside. Supports byte-level or delta diffing for binary files and code-analysis diffing to find changes in basic code blocks from radare code analysis or IDA ones using the idc2rdb rsc script.

\c rsc

Entrypoint for calling multiple small scripts and utilities that can be used from the shell.

\H{get} Getting radare

You can get radare from the website http://radare.nopcode.org/

There are binary packages for multiple operating systems and GNU/Linux distributions (ubuntu, maemo, gentoo, windows, iphone, etc..) But I hardly encourage you to get the sources and compile them yourself to better understand the dependencies and have the source code and examples more accessible.

I try to publish a new stable release every month and sometimes publish nightly tarballs.

But as always the best way to use a software is to go upstream and pull the development repository which in radare is commonly more stable than the 'stable' releases O:)

To do this you will need mercurial (a distributed python-based source code management aliased Hg) and type:

\c $ hg clone http://radare.nopcode.org/hg/radare

This will probably take a while, so take a coffee and continue reading this paper.

To update your local copy of the repository you will have to type these two commands in the root of the recently created 'radare' directory.

\c $ hg pull
\c $ hg update

If you have local modifications of the source, you can revert them with:

\c $ hg revert --all

Or just feed me with a patch

\c $ hg diff > radare-foo.patch

\H{compile} Compilation and portability

Currently the core of radare can be compiled in many systems, and architectures, but the main development is done on GNU/Linux and GCC.

People usually wants to use radare as a debugger for reverse engineering, and this is a bit more restrictive portability issue, so if the debugger is not ported to your favorite platform, please, notify it to me or just disable the debugger layer with --without-debugger in the ./configure stage.

Nowadays the debugger layer can be used on Windows, GNU/Linux (intel32, intel64, mips, arm), FreeBSD, NetBSD, OpenBSD (intel32, intel64) and there are plans for Solaris and OSX. And there are some IO plugins to use gdb, gdbremote or wine as backends.

There's some work for porting the ACR/GMAKE build system to WAF, but it's not finished or tested enought, so I encourage you to use the basic way to configure, compile and install the software:

\c $ ./configure --prefix=/usr
\c $ gmake
\c $ sudo gmake install

\H{cmdflags} Commandline flags

The core accepts multiple flags from the command line to change some configuration or start with different options.

Here's the help message:

\c $ radare -h
\c radare [options] [file]
\c   -s [offset]      seek to the desired offset (cfg.seek)
\c   -b [blocksize]   change the block size (512) (cfg.bsize)
\c   -i [script]      interpret radare or python/perl/lua script
\c   -p [project]     load metadata from project file
\c   -l [plugin.so]   link against a plugin (.so or .dll)
\c   -e [key=val]     evaluates a configuration string
\c   -d [program|pid] debug a program. same as --args in gdb
\c   -f               set block size to fit file size
\c   -L               list all available plugins
\c   -w               open file in read-write mode
\c   -x               dump block in hexa and exit
\c   -n               do not load ~/.radarerc and ./radarerc
\c   -v               same as -e cfg.verbose=false
\c   -V               show version information
\c   -u               unknown size (no seek limits)
\c   -h               this help message

\H{usage} Basic usage

Lot of people ping me some times for a sample usage session of radare to help to understand how the shell works and how to perform the most common tasks like disassembling, seeking, binary patching or debugging.

I hardly encourage you to read the rest of this book to help you understand better how everything works and enhace your skills, the learning curve of radare is usually a bit harder at the beggining, but after an hour of using it you will easily understand how most of the things work and how to get them cooperate together :)

For walking thru the binary file you will use three different kind of basic actions: seek, print and alterate.

To 'seek' there's an specific command abreviated as 's' than accepts an expression as argument that can be something like '10', '+0x25' or '[0x100+ptr_table]'. If you are working with block-based files you may prefer to set up the block size to 4K or the size required with the command 'b' and move forward or backward at seeks aligned to the block size using the '>' and '<' commands.

The 'print' command aliased as 'p', accepts a second letter to specify the print mode selected. The most common ones are 'px' for printing in hexadecimal, 'pd' for disassembling.

To 'write' open the file with 'radare -w'. This should be specified while opening the file, or just type 'eval file.write=true' in runtime to reopen the file in read-write-mode. You can use the 'w' command to write strings or 'wx' for hexpair strings:

\c > w hello world         ; string
\c > wx 90 90 90 90        ; hexpairs
\c > wa jmp 0x8048140      ; assemble
\c > wf inline.bin         ; write contents of file

Appending a '?' to the command you will get the help message of it. (p? for example)

Enter the visual mode pressing 'V<enter>', and return to the prompt using the 'q' key. 

In the visual mode you should use hjkl keys which are the default ones for scrolling (like left,down,up,right). So entering in cursor mode ('c') you will be able select bytes if using the shift together with HJKL.

In the visual mode you can insert (alterate bytes) pressing 'i' and then <tab> to switch between the hex or string column. Pressing 'q' in hex panel to return into the visual mode.

\H{usage-dbg} Basic debugger session

To start debugging a program use the '-d' flag and append the PID or the program path with arguments.

\c $ radare -d /bin/ls

The debugger will fork and load the 'ls' program in memory stopping the execution in the 'ld.so', so don't expect to see the entrypoint or the mapped libraries at this point. To change this you can define a new 'break entry point' adding 'e dbg.bep=entry' or 'dbg.bep=main' to your .radarerc.

But take care on this, because some malware or programs can execute code before the main.

Now the debugger prompt should appear and if you press 'enter' ( null command ) the basic view of the process will be displayed with the stack dump, general purpose registers and disassembly from current program counter (eip on intel).

All the debugger commands are handled by a plugin, so the 'system()' interface is hooked by it and you will have to supply them prefixing it with a '!' character.

Here's a list of the most common commands for the debugger:

\c > !help          ; get the help
\c > !step 3        ; step 3 times
\c > !bp 0x8048920  ; setup a breakpoint
\c > !bp -0x8048920 ; remove a breakpoint
\c > !cont          ; continue process execution
\c > !contsc        ; continue until syscall
\c > !fd            ; manipulate file descriptors
\c > !maps          ; show process maps
\c > !mp            ; change page protection permissions
\c > !reg eax=33    ; change a register

The easiest way to use the debugger is from the Visual mode, so, you will no need to remember much commands or keep states in your mind.

\c [0xB7F0C8C0]> Visual

After entering this command an hexdump of the current eip will be showed. Now press 'p' one time to get into the debugger view. You can press 'p' and 'P' to rotate thru the most commonly used print modes.

Use F6 or 's' to step into and F7 or 'S' to step over.

With the 'c' key you will toggle the cursor mode and being able to select range of bytes to nop them or set breakpoints using the 'F2' key.

In the visual mode you can enter commands with ':' to dump buffer contents like

\c x @ esi

To get the help in the visual mode press '?' and for the help of the debugger press '!'.

At this point the most common commands are !reg that can be used to get or set values for the general purpose registers. You can also manipulate the hardware and extended/floating registers.

\H{sample} Basic commands

The basic set of commands in radare can be mostly grouped by action, and they should be easy to remember and short. This is why they are grouped with a single character, subcommands or related commands are described with a second character. For example '/ foo' for searching plain strings or '/x 90 90' to look for hexpair strings.

The format of the commands looks something like that:

\c [#][!][cmd] [arg] [@ offset| @@ flags] [> file] [| shell-pipe] [ && ...]

This is: repeat the described command '#' times.

\c > 3s +1024    ; seeks three times 1024 from the current seek

If the command starts with '!' the string is passed to the plugin hadling the current IO (the debugger for example), if no one handles it calls to posix_system() which is a shell escape, you can prefix the command with two '!!'.

\c > !help       ; handled by the debugger or shell
\c > !!ls        ; runs ls in the shell

The [arg] argument depends on the command, but most of them take a number as argument to specify the number of bytes to work on instead of block size. Other commands accept math expressions, or strings.

\c > px 0x17     ; show 0x17 bytes in hexa at cur seek
\c > s base+0x33 ; seeks to flag 'base' plus 0x33
\c > / lib       ; search for 'lib' string.

The '@' is used to specify a temporal seek where the command is executed. This is quite useful to not seeking all the time.

\c > p8 10 @ 0x4010  ; show 10 bytes at offset 0x4010
\c > f patata @ 0x10 ; set 'patata' flag at offset 0x10

Using '@@' you can execute a single command on a list of flags matching the glob:

\c > s 0
\c > / lib             ; search 'lib' string
\c > p8 20 @@ hit0_*   ; show 20 hexpairs at each search hit

The '>' is used to pipe the output of the command to a file (truncating to 0 if exist)

\c > pr > dump.bin   ; dump 'raw' bytes of current block to 'dump.bin' file
\c > f  > flags.txt  ; dump flag list to 'flags.txt'

The '|' pipe is used to dump the output of the command to another program.

\c [0x4A13B8C0]> f | grep section | grep text
\c 0x0805f3b0 512 section__text
\c 0x080d24b0 512 section__text_end

Using the '&&' chars you can concatenate multiple commands in a single line:

\c > x @ esp && !reg && !bt  ; shows stack, regs and backtrace

\S{seek} Seeking

The command 's' is used to seek. It accepts a math expression as argument that can be composed by shift operations, basic math ones and memory access.

The '>' and '<' commands are used to seek into the file using a block-aligned base.

\c > >>>         ; seek 3 aligned blocks forward
\c > 3>          ; 3 times block-seeking
\c > s +30       ; seek 30 bytes forward from current seek
\c > s 0x300     ; seek at 0x300
\c > s [0x400]   ; seek at 4 byte dword at offset 0x400
\c > s 10+0x80   ; seek at 0x80+10

To 'query' the math expression you can evaluate them using the '?' command and giving the math operation as argument. And getting the result in hexa, decimal, octal and binary.

\c > ? 0x100+200
\c 0x1C8 ; 456d ; 710o ; 1100 1000  

\S{print} Print modes

One of the efforts in radare is the way to show the information to the user. This is interpreting the bytes and giving an almost readable output format.

The bytes can be represented as integers, shorts, longs, floats, timestamps, hexpair strings, or things more complex like C structures, disassembly, decompilations, external processors, ..

This is a list of the available print modes listable with 'p?':

\c [0x08049A80]> p?
\c Available formats:
\c  a : ascii                   (null)
\c  A : ascii printable         (null)
\c  b : binary                  N bytes
\c  B : LSB Stego analysis      N bytes
\c  c : C format                N bytes
\c  d : disassembly N opcodes   bsize bytes
\c  D : asm.arch disassembler   bsize bytes
\c  f : float                   4 bytes
\c  F : windows filetime        8 bytes
\c  i : integer                 4 bytes
\c  l : long                    4 bytes
\c  L : long long               8 bytes
\c  m : print memory structure  0xHHHH
\c  o : octal                   N bytes
\c  O : Zoom out view           entire file
\c  p : cmd.prompt              (null)
\c  % : print scrollbar of seek (null)
\c  r : raw ascii               (null)
\c  R : reference               (null)
\c  s : asm shellcode           (null)
\c  t : unix timestamp          4 bytes
\c  T : dos timestamp           4 bytes
\c  u : URL encoding            (null)
\c  U : executes cmd.user       (null)
\c  v : executes cmd.vprompt    (null)
\c  1 : p16: 16 bit hex word    2 bytes
\c  3 : p32: 32 bit hex dword   4 bytes
\c  6 : p64: 64 bit quad-word   8 bytes
\c  7 : print 7bit block as raw 8bit (null)
\c  8 : p8:   8 bit hex pair    N byte
\c  x : hexadecimal byte pairs  N byte
\c  z : ascii null terminated   (null)
\c  Z : wide ascii null end     (null)


\H{print-hexa}

User-friendly way:

\c [0x4A13B8C0]> px
\c    offset   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
\c 0x4A13B8C0, 89e0 e839 0700 0089 c7e8 e2ff ffff 81c3 ...9............
\c 0x4A13B8D0, eea6 0100 8b83 08ff ffff 5a8d 2484 29c2 ..........Z.$.).

Hexpairs:

\c [0x4A13B8C0]> p8
\c 89 e0 e8 39 07 00 00 89 c7 e8 e2 ff ff ff 81 c3 ee a6 01 00 8b 83 08 ff ff ff 5a 8d 24 84 29 c2 

Basic size types governed by endian:

16 bit words

\c [0x4A13B8C0]> p16 4
\c 0xe089 
\c 0x39e8 

32 bit doublewords

\c [0x4A13B8C0]> p32 4
\c 0x39e8e089 
\c [0x4A13B8C0]> e cfg.bigendian 
\c false
\c [0x4A13B8C0]> e cfg.bigendian = true
\c [0x4A13B8C0]> p32 4
\c 0x89e0e839 
\c [0x4A13B8C0]> 

64 bit dwords

\c [0x08049A80]> p8 16
\c 31 ed 5e 89 e1 83 e4 f0 50 54 52 68 60 9e 05 08 
\c [0x08049A80]> p64 16
\c 0x31ed5e89e183e4f0 
\c 0x50545268609e0508 

\H{print-dates}

The current supported timestamp print modes are:

\c  F : windows filetime        8 bytes
\c  t : unix timestamp          4 bytes
\c  T : dos timestamp           4 bytes

For example, you can 'view' the current buffer as timestamps in dos, unix or windows filetime formats:

\c [0x08048000]> eval cfg.bigendian = 0
\c [0x08048000]> pt 4
\c 30:08:2037 12:25:42 +0000

\c [0x08048000]> eval cfg.bigendian = 1
\c [0x08048000]> pt 4
\c 17:05:2007 12:07:27 +0000

As you can see, the endianness affects to the print formats. Once printing these filetimes you can grep the results by the year for example:

\c [0x08048000]> pt | grep 1974 | wc -l
\c 15
\c [0x08048000]> pt | grep 2022
\c 27:04:2022 16:15:43 +0000

\H{print-basic-types}

\c  f : float                   4 bytes
\c  i : integer                 4 bytes
\c  l : long                    4 bytes
\c  L : long long               8 bytes

\H{print-hexa}

\c  h : half word (short)       2 bytes
\c  w : hexadecimal word        2 bytes
\c  W : hexadecimal dword       4 bytes
\c  x : hexadecimal byte pairs  N byte
\c  X : hexadecimal string      N byte

\H{print-source}

\c  c : C format                N bytes
\c  s : asm shellcode           (null)

\H{print-strings}

\c  a : ascii                   (null)
\c  A : ascii printable         (null)
\c  r : raw ascii               (null)
\c  X : hexadecimal string      N byte
\c  z : ascii null terminated   (null)
\c  Z : wide ascii null end     (null)

\H{print-memory}

\c  m : print memory structure  0xHHHH

\H{print-code}

\c  d : disassembly N opcodes   bsize bytes
\c  D : asm.arch disassembler   bsize bytes

\S{zoom} Zoom

The zoom is a print mode that allows you to get a global view of the whole file or memory map in a single screen. Each byte represents file_size/block_size bytes of the file. Use the pO (zoom out print mode) to use it, or just toggle 'z' in the visual mode to zoom-out/zoom-in.

The cursor can be used to scroll faster thru the zoom out view and pressing 'z' again to zoom-in where the cursor points.

\c zoom.byte values:
\c  F : number of 0xFF
\c  f : number of flags
\c  p : number of printable chars
\c  e : entropy calculation
\c  * : first byte of block

For example. let's see some examples:

\c [0x08049790]> pO
\c    offset   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0 1  0123456789ABCDEF01
\c 0x00001790, 7fc7 0107 0141 b9e9 559b 3b85 f87d 7f89 ff05 .....A..U.;..}....
\c 0x00007730, 04c0 8505 c78b 7555 7dc3 0584 f8b0 8985 8900 ......uU}.........
\c 0x0000D6D0, 8b55 1485 fbff ffff ff50 83d0 6620 2020 6561 .U.......P..f   ea
\c 0x00013670, 6918 7f57 cc74 002e 2400                     i..W.t..$.   
\c 
\c [0x08049790]> eval zoom.byte = printable
\c [0x08049790]> pO
\c    offset   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0 1  0123456789ABCDEF01
\c 0x00001790, 7fc7 0107 0141 b9e9 559b 3b85 f87d 7f89 ff05 .....A..U.;..}....
\c 0x00007730, 04c0 8505 c78b 7555 7dc3 0584 f8b0 8985 8900 ......uU}.........
\c 0x0000D6D0, 8b55 1485 fbff ffff ff50 83d0 6620 2020 6561 .U.......P..f   ea
\c 0x00013670, 6918 7f57 cc74 002e 2400                     i..W.t..$.        
\c 
\c [0x08049790]> pO
\c    offset   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0 1  0123456789ABCDEF01
\c 0x00001790, 0202 0304 0505 0505 0505 0505 0505 0605 0505 ..................
\c 0x00007730, 0505 0505 0505 0505 0505 0606 0505 0505 0605 ..................
\c 0x0000D6D0, 0505 0405 0505 0505 0505 0505 0303 0303 0405 ..................
\c 0x00013670, 0403 0405 0404 0304 0303                     ..........        
\c 
\c [0x08049790]> eval zoom.byte = flags
\c [0x08049790]> pO
\c    offset   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0 1  0123456789ABCDEF01
\c 0x00001790, 0b04 1706 0400 0000 0000 0000 0000 0000 0000 ..................
\c 0x00007730, 0000 0000 0000 0000 0000 0000 0000 0000 0000 ..................
\c 0x0000D6D0, 0000 0000 0000 0000 0000 000d 1416 1413 165b .................[
\c 0x00013670, 1701 0e23 0b67 2705 0f12                     ...#.g'...        
\c 
\c [0x08049790]> eval zoom.byte = FF    
\c [0x08049790]> pO
\c    offset   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0 1  0123456789ABCDEF01
\c 0x00001790, 0000 0000 0000 0001 0000 0001 0000 0000 0200 ..................
\c 0x00007730, 0000 0100 0000 0000 0000 0000 0000 0101 0000 ..................
\c 0x0000D6D0, 0000 0001 0201 0202 0100 0000 0000 0000 0000 ..................
\c 0x00013670, 0000 0000 0002 0000 0000                     ..........        

\S{flagsmin} Flags

The flags are bookmarks at a certain offset in the file that can be stored inside 'flag spaces'. A flag space is something like a namespace for flags. They are used to group flags with similar characteristics or of a certain type. Some example of flagspaces could be [i]sections, registers, symbols, search hits[/i], etc.

To create a flag just type:

\c > f flag_name @ offset

You can remove this flag adding '-' at the begginging of the command. Most commands accept '-' as argument-prefix as a way to delete.

\c > f -flag_name

To switch/create between flagspaces use the 'fs' command:

\c [0x4A13B8C0]> fs   ; list flag spaces
\c 00   symbols
\c 01   imports
\c 02   sections
\c 03   strings
\c 04   regs
\c 05   maps

\c > fs symbols
\c > f         ; list only flags in symbols flagspace
\c ...
\c > fs *      ; select all flagspaces

You can create two flags with the same name with 'fn' or rename them with 'fr'.

\S{write} Writing bytes

Radare can manipulate the file in multiple ways. You can resize the file, move bytes, copy/paste them, insert mode (shifting data to the end of the block or file) or just overwrite some bytes with an address, the contents of a file, a widestring or inline assembling an opcode.

To resize. Use the 'r' command which accepts a numeric argument. Possitive valule sets the new size to the file. A negative one will strip N bytes from the current seek down-sizing the file.

\c > r 1024      ; resize the file to 1024 bytes
\c > r -10 @ 33  ; strip 10 bytes at offset 33

To write bytes just use the 'w' command. It accepts multiple input formats like inline assembling, endian-friendly dwords, files, hexpair files, wide strings:

\c [0x08049A80]> w?
\c Usage: w[?|w|x|f] [argument]
\c   w  [string]   - write plain with escaped chars string
\c   wa [opcode]   - write assembly using asm.arch and rasm
\c   wA '[opcode]' - write assembly using asm.arch and rsc asm
\c   wv [expr]     - writes 4-8 byte value of expr (use cfg.bigendian)
\c   ww [string]   - write wide chars (interlace 00s in string)
\c   wx [hexpair]  - write hexpair string
\c   wf [file]     - write contents of file at current seek
\c   wF [hexfile]  - write hexpair contents of file

\c > wx 12 34 56 @ 0x8048300
\c > wv 0x8048123 @ 0x8049100
\c > wa jmp 0x8048320

All write changes are recorded and can be listed or undo-ed using the 'u' command which is explained in the 'undo/redo' section.

\S{undo} Undo/redo

The 'u'ndo command is used to undo or redo write changes done on the file.

\c > u?
\c Usage: > u 3   ; undo write change at index 3
\c        > u -3  ; redo write change at index 3
\c        > u     ; list all write changes


Here's a sample session working with undo seeks and writes:

\c [0x00000000]> wx 90 90 90 @ 0x100
\c [0x00000100]> u                        ; list changes 
\c 00 + 3 00000100: 89 90 c4 => 90 90 90 

\c [0x00000000]> p8 3 @ 0x100
\c 90 90 90 
\c [0x00000000]> u 0
\c [0x00000000]> p8 3 @ 0x100
\c 89 90 c4 
\c [0x00000000]> u -0
\c [0x00000000]> p8 3 @ 0x100
\c 90 90 90 

\H{seeking} Seeking

The 's'eek command supports '+-*!' characters as arguments to perform acts on the seek history.

\c Usage: > s 0x128 ; absolute seek
\c        > s +33   ; relative seek
\c        > s-     ; undo seek
\c        > s+     ; redo seek
\c        > s*     ; show seek history
\c        > .s*    ; flag them all
\c        > s!     ; reset seek history

Here's a seesion example:

\c [0x00000000]> s 0x100
\c [0x00000100]> s 0x200
\c [0x00000200]> s-        ; undo last seek done
\c [0x00000100]>

\S{yank} Yank/Paste

You can yank/paste bytes in visual mode using the 'y' and 'Y' key bindings that are alias for the 'y' and 'yy' commands of the shell. There is an internal buffer that stores N bytes from the current seek. You can write-back to another seek using the 'yy' one.

\c > s 0x100    ; seek at 0x100
\c > y 100      ; yanks 100 bytes from here
\c > s 0x200    ; seek 0x200
\c > yy         ; pastes 100 bytes

\S{cmpmv} Compare/move data

The command 'm' is used to move data, which is something similar to 'yank/paste', but in a single command.

\c > m?
\c Usage: move [len] [dst-addr]
\c > m 10 0x300 @ 0x100  ; copy 10 bytes from 0x100 to 0x300

You can compare data using the 'c' command that accepts different input formats and compares the input against the bytes in the current seek.

\c > c?
\c Usage: c[?|d|x|f] [argument]
\c   c  [string]   - compares a plain with escaped chars string
\c   cd [offset]   - compare a doubleword from a math expression
\c   cx [hexpair]  - compare hexpair string
\c   cf [file]     - compare contents of file at current seek

An example of memory comparision:

\c [0x08048000]> p8 4
\c 7f 45 4c 46 
\c
\c [0x08048000]> cx 7f 45 90 46
\c Compare 3/4 equal bytes
\c 0x00000002 (byte=03)   90 ' '  ->  4c 'L'
\c [0x08048000]> 

This is also useful for comparing memory pointers at certain offsets. The variable cfg.bigendian is used to change the value in the proper way to be compared against the contents at the '0x4A13B8C0' offset:

\c [0x4A13B8C0]> cd 0x39e8e089 @ 0x4A13B8C0
\c Compare 4/4 equal bytes
\c
\c [0x4A13B8C0]> p8 4
\c 89 e0 e8 39 

It takes 4 bytes from the current seek (0x4A13B8C0) and compares them to the number given. This number can be an math expressions using flag names and so:

\c [0x08048000]> cx 7f 45 90 46
\c Compare 3/4 equal bytes
\c 0x00000002 (byte=03)   90 ' '  ->  4c 'L'
\c [0x08048000]> 

We can use the compare command against a file previously dumped to disk from the contents of the current block.

\c $ radare /bin/true
\c [0x08049A80]> s 0
\c [0x08048000]> cf /bin/true
\c Compare 512/512 equal bytes

\C{config} Configuration

The core reads ~/.radarerc while starting, so you can setup there some 'eval' commands to set it up in your favorite way.

To avoid parsing this file, use '-n' and to get a cleaner output for using radare in batch mode maybe is better to just drop the verbosity with '-v'.

All the configuration of radare is done with the 'eval' command which allows the user to change some variables from an internal hashtable containing string pairs.

The most common configuration looks like this:

\c $ cat ~/.radarerc
\c eval scr.color = true
\c eval file.id   = true
\c eval file.flag = true
\c eval dbg.bep   = entry

These configurations can be also defined using the '-e' flag of radare while loading it, so you can setup different initial configurations from the commandline without having to change to rc file.

\c $ radare -n -e scr.color=true -e asm.syntax=intel -d /bin/ls

All the configuration is stored in a hash table grouped by different root names ([i]cfg., file., dbg., ..[/i])

To get a list of the configuration variables just type 'eval' or 'e' in the prompt. All the basic commands can be reduced to a single char. You can also list the configuration variables of a single eval configruation group ending the command argument with a dot '.'.

There are two enhaced interfaces to help users to interactively configure this hashtable. One is called 'emenu' and provides a shell for walking through the tree and change variables. 

To get a help about this command you can type 'e?':

[0x4A13B8C0]> e?
Usage: e[m] key=value
   > ereset              ; reset configuration
   > emenu               ; opens menu for eval
   > e scr.color = true  ; sets color for terminal

Note the 'e' of emenu, which stands for 'eval'. In radare, all basic commands can be reduced to a single char, and you can just type 'e?' to get the help of all the 'subcommands' for the basic command.

\c [0xB7EF38C0]> emenu
\c Menu: (q to quit)
\c - asm
\c - cfg
\c - child
\c - cmd
\c - dbg
\c - dir
\c - file
\c - graph
\c - scr
\c - search
\c - trace
\c - zoom
\c >

There is a easier eval interface accessible from the Visual mode, just typing 'e' after entering this mode (type 'Visual' command before).

Most of the eval tree is quite stable, so don't expect hard changes on this area. 

I encourage you to experiment a bit on this to fit the interface to your needs.

\H{common-conf} Common configuration variables

Here's a list of the most common eval configuration variables, you can get the complete list using the 'e' command without arguments or just use 'e cfg.' (ending with dot, to list all the configuration variables of the cfg. space).

\c asm.arch

Defines the architecture to be used while disassembling (pd, pD commands) and analyzing code ('a' command). Currently it handles 'intel32', 'intel64', 'mips', 'arm16', 'arm' 'java', 'csr', 'sparc', 'ppc', 'msil' and 'm68k'.

It is quite simple to add new architectures for disassembling and analyzing code, so there is an interface adapted for the GNU disassembler and others for udis86 or handmade ones.

\c asm.syntax

Defines the syntax flavour to be used while disassembling. This is currently only targeting the udis86 disassembler for the x86 (32/64 bits). The supported values are 'intel', 'att' and 'pseudo'.

\c asm.os

Defines the target operating system of the binary to analyze. This is automatically defined by 'rabin -rI' and it's useful for switching between the different syscall tables and perform different depending on the OS.

\c asm.flags

If defined to 'true' shows the flags column inside the disassembly.

\c asm.lines

Draw lines at the left of the offset in the dissassemble print format (pd, pD) to graphically represent jumps and calls inside the current block.

\c asm.linesout

When defined as 'true', also draws the jump lines in the current block that goes ouside of this block.

\c asm.linestyle

Can get 'true' or 'false' values and makes the line analysis be performed from top to bottom if false or bottom to top if true. 'false' is the optimal and default value for readability.

\c asm.offset

Boolean value that shows or hides the offset address of the disassembled opcode

\c asm.bytes

Boolean value that shows or hides the bytes of the disassebled opcode

\c cfg.bigendian

Choose the endian flavour 1 for big, 0 for little.

\c file.id

When enabled (set it up to '1' or 'true'). Runs rabin -rI after opening the target file and tries to identify the file type and setup the base address and stuff like that.

\c file.flag

Finds all the information of the target binary and setup flags to point symbols (imports, exports), sections, maps, strings, etc.

This command is commonly used with file.id.

\c scr.color

This boolean variable allows to enable or disable the colorized output

\c cfg.fortunes

Enables or disables the 'fortune' message at the begging of the program

\C{visual-mode} Visual mode

The visual mode is a user-friendlier interface for the commandline prompt of radare which accepts HJKL movement keys, a cursor for selecting bytes and some keybindings to ease the use of the debugger.

In this mode you can change the configuration in a easy way using the 'e' (eval) key. Or just track the flags and walk thru the flagspaces pressing 't'.

To get a help of all the keybindings hooked in visual mode you can press '?':

\c Visual keybindings:
\c :<cmd>     radare command (vi like)
\c ;          edit or add comment
\c ,.         ',' marks an offset, '.' seeks to mark or eip if no mark
\c g,G        seek to beggining or end of file
\c +-*/       +1, -1, +width, -width -> block size
\c <>         seek block aligned (cursor mode = folder code)
\c []         adjust screen width
\c a,A,=      insert patch assembly, rsc asm or !hack
\c i          insert mode (tab to switch btw hex,asm,ascii, 'q' to normal)
\c f,F        seek between flag list (f = forward, F = backward)
\c t          visual track/browse flagspaces and flags
\c e          visual eval configuration variables
\c c          toggle cursor mode
\c C          toggle scr.color
\c d          convert cursor selected bytes to ascii, code or hex
\c m          applies rfile magic on this block
\c I          invert block (same as pIx or so)
\c y,Y        yank and Yankee aliases for copy and paste
\c f,F        go next, previous flag (cursor mode to add/remove)
\c h,j,k,l    scroll view to left, down, up, right.
\c J,K        up down scroll one block.
\c H,L        scroll left, right by 2 bytes (16 bits).
\c p,P        switch between hex, bin and string formats
\c x          show xrefs of the current offset
\c q          exits visual mode
\c 
\c Debugger keybindings:
\c !          show debugger commands help
\c F1         commands help
\c F2         set breakpoint (execute)
\c F3         set watchpoint (read)
\c F4         continue until here (!contuh)
\c F6         continue until syscall (!contsc)
\c F7         step in debugger user code (!step)
\c F8         step over in debugger (!stepo)
\c F9         continue execution (!cont)
\c F10        continue until user code (!contu)

From the visual mode you can toggle the insert and cursor modes with the 'i' and 'c' keys.

\H{visual-mode-cursor} Visual cursor

Pressing lowercase 'c' makes the cursor appear or disappear. The cursor is used to select a range of bytes or just point to a byte to flag it (press 'f' to create a new flag where the cursor points to)

If you select a range of bytes press 'w' and then a byte array to overwrite the selected bytes with the ones you choose in a circular copy way. For example:

\c <select 10 bytes in visual mode>
\c <press 'w' and then '12 34'>
\c The 10 bytes selected will become: 12 34 12 34 12 34 12 34 12 34

The byte range selection can be used together with the 'd' key to change the data type of the selected bytes into a string, code or a byte array.

That's useful to enhace the disassembly, add metadata or just align the code if there are bytes mixed with code.

\H{visual-mode-insert} Visual insert

The insert mode allows you to write bytes at nibble-level like most common hexadecimal editors. In this mode you can press '<tab>' to switch between the hexa and ascii columns of the hexadecimal dump.

To get back to the normal mode, just press '<tab>' to switch to the hexadecimal view and press 'q'. (NOTE: if you press 'q' in the ascii view...it will insert a 'q' instead of quit this mode)

\C{searching} Searching bytes

The search engine of radare is based on the work done by esteve plus multiple features on top of it that allows multiple keyword searching with binary masks and automatic flagging of results.

This powerful command is '/'.

\c [0x00000000]> /?
\c  / \x7FELF      ; plain string search (supports \x).
\c  /. [file]      ; search using the token file rules
\c  /s [string]    ; strip strings matching optional string
\c  /x A0 B0 43    ; hex byte pair binary search.
\c  /k# keyword    ; keyword # to search
\c  /m# FF 0F      ; Binary mask for search '#' (optional)
\c  /a [opcode]    ; Look for a string in disasembly
\c  /A             ; Find expanded AES keys from current seek(*)
\c  /w foobar      ; Search a widechar string (f\0o\0o\0b\0..)
\c  /r 0,2-10      ; launch range searches 0-10
\c  /p len         ; search pattern of length = len
\c  //             ; repeat last search

The search is performed from the current seek until the end of the file or 'cfg.limit' if != 0. So in this way you can perform limited searches between two offsets of a file or the process memory.

With radare everything is handled as a file, it doesn't matters if it is a socket, a remote device, the process memory, etc..

\H{search-simple} Basic searchs

A basic search for a plain string in a whole file would be something like:

\c $ echo "/ lib" | radare -nv /bin/ls
\c 001  0x00000135  hit0_0 lib/ld-linux.so.2
\c 002  0x00000b71  hit0_1 librt.so.1__gmon_st
\c 003  0x00000bad  hit0_2 libselinux.so.1_ini
\c 004  0x00000bdd  hit0_3 libacl.so.1acl_exte
\c 005  0x00000bfb  hit0_4 libc.so.6_IO_stdin_
\c 006  0x00000f2a  hit0_5 libc_start_maindirf
\c $

As you can see, radare generates a 'hit' flag for each search result found. You you can just use the 'pz' command to visualize the strings at these offsets in this way:

\c [0x00000000]> / ls
\c ...
\c [0x00000000]> pz @ hit0_0
\c lib/ld-linux.so.2

We can also search wide-char strings (the ones containing zeros between each letter) using the '/w' in this way:

\c [0x00000000]> /w Hello
\c 0 results found.

It is also possible to mix hexadecimal scape sequences in the search string:

\c $ radare -u /dev/mem
\c [0x00000000]> / \x7FELF

But if you want to perform an hexadecimal search you will probably prefer an hexpair input with '/x':

\c [0x00000000]> /x 7F 45 4C 46

Once the search is done, the results are stored in the 'search' flag space.

\c [0x00000000]> fs search
\c [0x00000000]> f
\c 0x00000135 512 hit0_0
\c 0x00000b71 512 hit0_1
\c 0x00000bad 512 hit0_2
\c 0x00000bdd 512 hit0_3
\c 0x00000bfb 512 hit0_4
\c 0x00000f2a 512 hit0_5

To remove these flags, you can just use the 'f -hit*' command.

Sometimes while working long time in the same file you will need to launch the last search more than once and you will probably prefer to use the '//' command instead of typing all the string again.

\c [0x00000f2a]> //     ; repeat last search

\H{search-pattern} Pattern search

The search command allows you to throw repeated pattern searchs against the IO backend to be able to identify repeated sequences of bytes without specifying them. The only property to perform this search is to manually define the minimum length of these patterns.

Here's an example:

\c [0x00000000]> /p 10

The output of the command will show the different patterns found and how many times they are repeated.

\H{search-backward} Backward search

TODO (not yet implemented)

\H{search-binmask} Binary masks


\H{search-multiple} Multiple keywords

TODO: ranges, keyword management

\H{search-filerules} Search using rules file

TODO

\H{search-asm} Search in assembly

TODO: pd | grep foo

\H{search-aes-keys} Searching AES keys

Thanks to Victor Muñoz i have added support to the algorithm he developed to find expanded AES keys. It runs the search from the current seek to the cfg.limit or the end of the file. You can always stop the search pressing ^C.

\c $ sudo radare /dev/mem
\c [0x00000000]> /A
\c 0 AES keys found

\C{disasm} Disassembling

Disassembling in radare is just a way to represent a bunch of bytes. So it is handled as a print mode with the 'p' command.

In the old times when radare core was smaller. The disassembler was handled by an external rsc file, so radare was dumping the current block into a file, and the script was just calling objdump in a proper way to disassemble for intel, arm, etc...

Obviously this is a working solution, but takes too much cpu for repeating just the same task so many times, because there are no caches and the scrolling was absolutely slow.

Nowadays, the disassembler is one of the basics in radare allowing you to choose the architecture flavour and some 
To disassemble use the 'pd' command.

The 'pd' command accepts a numeric argument to specify how many opcodes of the current block do you want to disassemble. Most of the commands in radare are restricted by the block size. So if you want to disassemble more bytes you should use the 'b' command to specify the new block size.

\c [0x00000000]> b 100    ; set block size to 100
\c [0x00000000]> pd       ; disassemble 100 bytes
\c [0x00000000]> pd 3     ; disassemble 3 opcodes
\c [0x00000000]> pD 30    ; disassemble 30 bytes

The 'pD' command works like 'pd' but gets the number of bytes instead of the number of opcodes.

The 'pseudo' syntax is closer to the humans, but it can be anoying if you are reading lot of code:

\c [0xB7FB8810]> e asm.syntax=pseudo
\c [0xB7FB8810]> pd 3
\c 0xB7FB8810,    eax = esp        
\c 0xB7FB8812   v call 0xB7FB8A60
\c 0xB7FB8817     edi += eax        
\c
\c [0xB7FB8810]> e asm.syntax=intel
\c [0xB7FB8810]> pd 3
\c 0xB7FB8810,  mov eax, esp        
\c 0xB7FB8812   call 0xb7fb8a60
\c 0xB7FB8817   add edi, eax        
\c
\c [0xB7FB8810]> e asm.syntax=att
\c [0xB7FB8810]> pd 3
\c 0xB7FB8810,  mov %esp, %eax          
\c 0xB7FB8812   call 0xb7fb8a60
\c 0xB7FB8817   add %eax, %edi          
\c [0xB7FB8810]> 

\H{metadata} Adding metadata

The work on binary files makes the task of taking notes and defining information on top of the file quite important. Radare offers multiple ways to retrieve and adquire this information from many kind of file types.

Following some *nix principles becomes quite easy to write a small utility in shellscript that using objdump, otool, etc.. to get information from a binary and import it into radare just making echo's of the commands script.

You can have a look on one of the many 'rsc' scripts that are distributed with radare like 'idc2rdb':

\c  $ cat src/rsc/pool/idc2rdb
\c 
\c while(<STDIN>) {
\c         $str=$_;
\c         if ($str=~/MakeName[^X]*.([^,]*)[^"]*.([^"]*)/) {
\c                 print "f idc_$2 @ 0x$1\n";
\c         }
\c         elsif ($str=~/MakeRptCmt[^X]*.([^,]*)[^"]*.([^"]*)/) {
\c                 $cmt = $2;
\c                 $off = $1;
\c                 $cmt=~s/\\n//g;
\c                 print "CC $cmt @ 0x$off\n";
\c         }
\c }

This script is called with 'rsc idc2rdb < file.idc > file.rdb'. It reads an IDC file exported from an IDA database and imports the comments and the names of the functions.

We can import the 'file.rdb' using the '.' command of radare (similar to the shell):

\c [0x00000000]> . file.rdb

The command '.' is used to interpret data from external resources like files, programs, etc.. In the same way we can do the same without writing a file.

\c [0x00000000]> .!rsc idc2rdb < file.idc

The 'C' command is the one used to manage comments and data conversions. So you can define a range of bytes to be interpreted as code, or a string. It is also possible to define flags and execute code in a certain seek to fetch a comment from an external file or database.

Here's the help:

\c Usage: C[op] [arg] <@ offset>
\c  CC [-][comment] @ here - add/rm comment
\c  CF [-][len]  @ here    - add/rm function
\c  Cx [-][addr] @ here    - add/rm code xref
\c  CX [-][addr] @ here    - add/rm data xref
\c  Cc [num]     - converts num bytes to code
\c  Cd [num]     - converts to data bytes
\c  Cs [num]     - converts to string
\c  Cf [num]     - folds num bytes
\c  Cu [num]     - unfolds num bytes
\c  C*           - list metadata database

For example, if you want to add a comment just type:

\c [0x00000000]> CC this guy seems legit @ 0x8048536

You can execute code inside the disassembly just placing a flag and assigning a command to it:

\c [0x00000000]> fc !regs @ eip

This way radare will show the registers of the cpu printing the opcode at the address where 'eip' points.

In the same way you can interpret structures or fetch information from external files. If you want to execute more than one command in a single address you will have to type them in a file and use the '.' command as explained before.

\c [0x00000000]> fc . script @ eip

The 'C' command allows us to change the type of data. The three basic types are: code (disassembly using asm.arch), data (byte array) or string.

In visual mode is easier to manage this because it is hooked to the 'd' key trying to mean 'data type change'. Use the cursor to select a range of bytes ('c' key to toggle cursor mode and HJKL to move with selection) and then press 'ds' to convert to string.

You can use the Cs command from the shell also:

\c [0x00000000]> pz 0x800
\c HelloWorld
\c [0x00000000]> f string_foo @ 0x800
\c [0x00000000]> Cs 10 @ string_foo

The folding/unfolding is quite premature but the idea comes from the 'folder' concepts in vim. So you can select a range of bytes in the disassembly view and press '<' to fold these bytes in a single line or '>' to unfold them. Just to ease the readability of the code.

\C{iobackend} IO backend

All the access to files, network, debugger, etc.. is wrapped by an IO abstraction layer that allows to interpret all the data as if it was a single file.

The IO backend is implement as IO plugins. They are selected depending on the uri file.

\c # debug this file using the debug io plugin
\c $ radare dbg:///bin/ls
\c
\c # allocate 10MB in a malloc buffer
\c $ radare malloc://10M
\c
\c # allocate 10MB in a malloc buffer
\c $ radare malloc://10M
\c 
\c # connect to remote host
\c $ radare connect://192.168.3.33:9999

\C{plugins} Plugins

Radare can be extended in many ways. The most common is by using stdin/stdout get input from a file an interpret the output of the program execution as radare commands. stderr is used for direct user messaging, because it is not handled by the core and it is directly printed in the terminal.

But with this kind of plugins are not directly interactive, because the communication is one-way from the external program to radare. and the only way to get feedback from radare is by using pipes and files. For example:

\c $ cat interactive.rsc
\c #!/bin/sh
\c addr=$1
\c if [ -z "${addr}" ]; then
\c    echo "No address given"
\c    exit 1
\c fi
\c echo "p8 4 > tmpfile"
\c sleep 1
\c bytes=`cat tmpfile`
\c echo "wx ${bytes} @ ${addr}+4"

What this 'dummy' script does is get an address as argument, read 4 bytes from there, and write them at address+4.

As you see this simple task becomes quite 'ugly' using this concepts, so its better to write a native plugin to get full access to the radare internals

\H{plugins-io} IO plugins

IO plugins are the ones used to wrap the open, read, write and 'system' on virtual file systems.

The cool thing of IO plugins is that you can make radare understand that any thing can be handled as a plain file. A socket connection, a remote radare session, a file, a process, a device, a gdb session, etc..

So, when radare reads a block of bytes, is the task of the IO plugin to get these bytes from any place and put them in the internal buffer.

IO plugins are selected while opening a file by its URI. Here'r some examples:

\c # Debugging URIs
\c $ radare dbg:///bin/ls
\c $ radare pid://1927
\c
\c # Remote sessions
\c $ radare listen://:9999
\c $ radare connect://localhost:9999
\c
\c # Virtual buffers
\c $ radare malloc://1024

You can get a list of the radare IO plugins by typing 'radare -L':

\c $ radare -L
\c haret       Read WCE memory ( haret://host:port )
\c debug       Debugs or attach to a process ( dbg://file or pid://PID )
\c gdb         Debugs/attach with gdb (gdb://file, gdb://PID, gdb://host:port)
\c gdbx        GDB shell interface 'gdbx://program.exe args' )
\c shm         shared memory ( shm://key )
\c mmap        memory mapped device ( mmap://file )
\c malloc      memory allocation ( malloc://size )
\c remote      TCP IO ( listen://:port or connect://host:port )
\c winedbg     Wine Debugger interface ( winedbg://program.exe )
\c socket      socket stream access ( socket://host:port )
\c gxemul      GxEmul Debugger interface ( gxemul://program.arm )
\c posix       plain posix file access


\H{plugins-hack} Hack plugins

The hack plugins are just shared libraries that have access to some internal apis of radare. The most important one "radare_cmd" which accepts a command string and returns the string representing the output of the execution.

In this way it is possible to perform any action in the core just formatting command strings and parsing its output.

\c{Language bindings}

All language bindings supported by radare to script some actions are implemented as hack plugins.

LUA is probably the cleaner implementation of a language binding for radare, i recommend you to read the source at 'src/plug/hack/lua.c'. Here's the structure to register the plugin:

\c int radare_plugin_type = PLUGIN_TYPE_HACK;
\c struct plugin_hack_t radare_plugin = {
\c         .name = "lua",
\c         .desc = "lua plugin",
\c         .callback = &lua_hack_cmd
\c };

The 'lua_hack_cmd' accepts a string as argument which is the argument given when calling the plugin from the radare shell:

\c [0x00000000]> H lua my-script.lua

If no arguments given, the plugin will loop in a prompt executing the lines given as lua statements.

The same happens with other language bindings like python or perl.

In the same directory where the plugins are installed, there's a "radare.py" or "radare.lua" which describes the API for that language.

The APIs in radare for language bindings are just wrappers for the basic 'r.cmd()' function handled by the core which is hooked to 'radare_cmd()'.

Here's a small part of radare.py to exemplify this:

\c def flag_get(name):
\c         return r.cmd("? %s"%name).split(" ")[0].strip()
\c
\c def flag_set(name, addr=None):
\c         if addr == None:
\c                 r.cmd("f %s"%name)
\c         else:
\c                 r.cmd("f %s @ 0xx"%name, addr)
\c
\c def analyze_opcode(addr=None):
\c         """
\c         Returns a hashtable containing the information of the analysis of the opcode in the current seek.
\c         This is: 'opcode', 'size', 'type', 'bytes', 'offset', 'ref', 'jump' and 'fail'
\c         """
\c         if addr == None:
\c                 return __str_to_hash(r.cmd("ao"))
\c         return __str_to_hash(r.cmd("ao @ 0x%x"%addr))

The use of these functions is quite natural:

\c from radare import *
\c
\c aop = analyze_opcode(flag_get("eip"))
\c if aop["type"] == "jump":
\c        print "Jumping to 0x%08x"%aop["jump"]

Read the 'scripting' chapter to get a deeper look on this topic.

\C{rabin} Rabin 

Under this bunny-arabic-like name, radare hides the power of a wonderful tool to handle binary files and get information to show it in the command line or import it into the core.

Rabin is able to handle multiple file formats like Java CLASS, ELF, PE, MACH-O, etc.. and it is able to get symbol import/exports, library dependencies, strings of data sections, xrefs, address of entrypoint, sections, architecture type, etc.

\c $ rabin -h
\c rabin [options] [bin-file]
\c  -e        shows entrypoints one per line
\c  -i        imports (symbols imported from libraries)
\c  -s        symbols (exports)
\c  -c        header checksum
\c  -S        show sections
\c  -l        linked libraries
\c  -L [lib]  dlopen library and show address
\c  -z        search for strings in elf non-executable sections
\c  -x        show xrefs of symbols (-s/-i required)
\c  -I        show binary info
\c  -r        output in radare commands
\c  -v        be verbose

TODO

\C{net} Networking

Radare have some interesting features in the networking area. It can be used as a hexadecimal netcat-like application using the io socket plugin which offers a file-like interface to access a TCP/IP connection.

TODO

\H{net-iosocket}

It generates a malloc-ed buffer which grows when receiving data from the socket and writing data to it in 

TODO

\H{net-connect}

TODO

\H{net-sysproxy}

TODO

\C{rsc} rsc toolset

RSC stands for 'radare scripts' which are a set of scripts accessible thru the 'rsc' command and allow to perform different tasks or provide small utilities that can interact with radare in some way.

\H{rsc-asmdasm} asm/dasm

TODO

\H{rsc-syms} syms

TODO

\H{rsc-idc2rdb} idc2rdb

TODO

\H{rsc-gokolu} gokolu

TODO

\C{rasm} rasm the inline (a/disa)ssembler

Initially 'rasm' was designed to be used for binary patching, just to get the bytes of a certain opcode.

TODO

\C{anal} Analysis

There are different commands to perform data and code analysis and extract information like pointers, string references, basic blocks, extract opcode information, jump information, xrefs, etc..

Those operations are handled by the root 'a'nalyze command:

\c Usage: a[ocdg] [depth]
\c  ao [nops]    analyze N opcodes
\c  ab [num]     analyze N code blocks
\c  af [name]    analyze function
\c  ac [num]     disasm and analyze N code blocks
\c  ad [num]     analyze N data blocks 
\c  ag [depth]   graph analyzed code
\c  as [name]    analyze spcc structure (uses dir.spcc)
\c  at [args]    analyze opcode traces
\c  av [nops]    analyze virtual machine (negative resets before)
\c  ax           analyze xrefs

\H{codeanal} Code analysis

About code analysis radare can work with functions, basic blocks, opcodes.

-- ao: opcode
-- ab: block
-- af: function
-- ac: anlayze code
-- av: analyze using virtual machine

TODO

\c [0xB7F14810]> H python
\c python> op = analyze_opcode()
\c python> print "0x%x\n"%op['offset']
\c 0xb7f14810


\H{dataanal} Data analysis

- structures (as)
- raw data (ad)

TODO

\H{anal-trace} Trace analysis

The radare debugger stores information about the executed opcodes in a linked list and allows later to get an execution trace of the code with a list of ranged addresses of the executed code and how many times and in which order these instructions has been executed.

This information is managed with the 'at' command. 'Analyze Traces'.

\c [0x4A13C00E]> at
\c 0x4a13b8c0 - 0x4a13b8c7
\c 0x4a13c000 - 0x4a13c048
\c 0x4a13c050 - 0x4a13c066
\c 0x4a1508cb - 0x4a1508cf

To get a complete list of all the executed addresses use 'at*'. The first column represents the offset and the second one the number of times it has been executed and the third one the last step counter value for this offset.

\c [0x4A13C00E]> at*
\c 0x4a13b8c0 1 1
\c 0x4a13b8c2 1 2
\c 0x4a13c000 1 3
\c 0x4a13c001 1 4
\c 0x4a13c003 1 5
\c 0x4a13c004 1 6
\c 0x4a13c005 1 7
\c 0x4a13c006 1 8
\c 0x4a13c009 1 9
\c 0x4a1508cb 1 10
\c 0x4a1508ce 1 11
\c 0x4a13c00e 1 12
\c 0x4a13c014 1 13
\c 0x4a13c017 1 14
\c 0x4a13c019 1 15
\c 0x4a13c01f 1 16
\c 0x4a13c025 1 17
\c 0x4a13c02b 1 18
\c 0x4a13c031 1 19
\c 0x4a13c033 1 20
\c 0x4a13c036 1 21
\c 0x4a13c03c 1 22
\c 0x4a13c042 1 23
\c 0x4a13c044 1 24
\c 0x4a13c046 1 25
\c 0x4a13c061 5 54
\c 0x4a13c064 5 55
\c 0x4a13c050 5 56
\c 0x4a13c057 5 57
\c 0x4a13c05a 5 58
\c 0x4a13c05d 5 59
\c 0x4a13c05f 4 53
\c [0x4A13C00E]> 

With this log we can easily identify the loops, how many times they have been executed and the execution order of them.

You can also get detailed information of a certain offset:

\c [0x4A13C05A]> !at 0x4a13c064
\c ffset = 0x4a13c064
\c opsize = 2
\c times = 5
\c count = 55

\C{Hashing} Hashing data

The it is quite easy to calculate a hash checksum of the current block using the '#' command.

Change the block size, seek to the interesting offset and calculate the md5 of it.

\c $ radare /bin/ls
\c [0x08048000]> s section__text
\c [0x08049790]> b section__text_end-section__text
\c [0x08049790]> #md5
\c d2994c75adaa58392f953a448de5fba7

In the same way you can also calculate other hashing algorithms that are supported by 'rahash': md4, md5, crc16, crc32, sha1, sha256, sha384, sha512, par, xor, xorpair, mod255, hamdist, entropy, all.

The '#' command can accept a numeric argument to define the length in bytes to be hashed.

\c [0x08049A80]> #md5 32
\c 9b9012b00ef7a94b5824105b7aaad83b
\c [0x08049A80]> #md5 64
\c a71b087d8166c99869c9781e2edcf183
\c [0x08049A80]> #md5 1024
\c a933cc94cd705f09a41ecc80c0041def
\c [0x08049A80]> 

\H{rahash} Rahash tool

The rahash tool is the used by radare to realize these calculations. It 

\c $ rahash -h
\c rahash [-action] [-options] [source] [hash-file]
\c  actions:
\c   -g           generate (default action)
\c   -c           check changes between source and hash-file
\c   -o           shows the contents of the source hash-file
\c   -A           use all hash algorithms
\c  options:
\c   -a [algo]    algorithm to hash (md4, md5, crc16, crc32, sha1, sha256, sha384, sha512, par, xor, xorpair, mod255, hamdist, entropy, all)
\c   -s [string]  hash this string instead of a file
\c   -S [offset]  seek initial offset to
\c   -E [offset]  end hashing at offset
\c   -L [length]  end hashing at length
\c   -b [size]    sets the block size (default 32KB)
\c   -f           block size = file size (!!)
\c   -q           quite output (can be combined with -v)
\c   -V           show version information
\c   -v           be verbose

It permits the calculation of the hashes from strings or files.

\c $ rahash -a md5 -s 'hello world'
\c 5eb63bbbe01eeed093cb22bb8f5acdc3

It is possible to hash the full contents of a file by giving '-f' as argument. But dont do this for large files like disks or so, because rahash stores the buffer in memory before calculating the checksum instead of doing it progressively.

\c $ rahash -a all -f /bin/ls
\c par:     1
\c xor:     ae
\c hamdist: 00
\c xorpair: 11bf
\c entropy: 6.08
\c mod255:  ea
\c crc16:   41a4
\c crc32:   d34e458d
\c md4:     f0bfd80cea21ca98cc48aefef8d71f3e
\c md5:     f58860f27dd2673111083770c9445099
\c sha1:    bfb9b77a29318fc6a075323c67af74d5e3071232
\c sha256:  8c0d752022269a8673dc38ef5d548c991bc7913a43fe3f1d4d076052d6a5f0b6
\c sha384:  1471bd8b14c2e11b3bcedcaa23209f2b87154e0daedf2f3f23053a598685850318ecb363cf07cf48410d3ed8e9921573
\c sha512:  03c63d38b0286e9a6230ffd39a1470419887ea775823d21dc03a2f2b2762a24b496847724296b45e81a5ff607cc46ef0f46e4eb1b8faa67ea3c463999f7b5864

rahash is designed to work with blocks like radare does. So this way you can generate multiple checksums from a single file, and then make a faster comparision of the blocks to find the part of the file that has changed.

This is useful in forensic tasks, when progressively analyzing memory dumps to find the places where it has changed and then use 'radiff' to get a closer look to these changes.

This is the default work way for rahash. So lets generate a rahash checksumming file and then use it to check if something has changed. The default block size is 32 KBytes. You can change it by using the -b flag.

\c # generate ls.rahash
\c $ rahash -g -a sha1 /bin/ls ls.rahash
\c 91c9cc53e7c7204027218ba372e9e738
\c f5547b7cd016678bebc61b4b0ca3a442
\c 5fd03cecbbad68314bc82f2f7db2f6aa
\c 
\c # show values stored in rahash file:
\c $ rahash -vo ls.hash 
\c file_name  /bin/ls
\c offt_size  8
\c endian     0 (little)
\c version    1
\c block_size 32768
\c file_size  92376
\c fragments  3
\c file_name  /bin/ls
\c from       0
\c to         92376
\c length     92376
\c algorithm  md5
\c algo_size  16
\c 0x00000000 91C9CC53E7C7204027218BA372E9E738
\c 0x00008000 F5547B7CD016678BEBC61B4B0CA3A442
\c 0x00010000 5FD03CECBBAD68314BC82F2F7DB2F6AA
\c 
\c # check if something has changed
\c $ rahash -c -a sha1 /bin/ls ls.rahash

You can also specify some limits when calculating checksummings, so, you can easily tell rahash to start hashing at a certain seek and finish after N bytes or just when reaching another offset.

\c   -S [offset]  seek initial offset to
\c   -E [offset]  end hashing at offset
\c   -L [length]  end hashing at length

f.example:

\c $ rahash -S 10 -L 20 /bin/ls
\c 4b01adea1951a55cdf05f92cd4b2cf75

\C{bindiff-index} Binary diffing

Radiff is the program used in radare to identify changes and delta offsets between two binary files. It implements different algorithms to find and show this information:

\c $ radiff -h
\c Usage: radiff [-c] [-bgeirp] [file-a] [file-b]
\c   -b   bytediff (faster but doesnt support displacements)
\c   -d   use gnu diff as backend (default)
\c   -e   use erg0ts bdiff (c++) as backend
\c   -r   use rdb diff (code analysis diff)
\c   -s   use rsc symdiff
\c   -S   use rsc symbytediff
\c   -p   binpatching (TODO)

\H{bytediff} Diffing at byte-level

The byte-level binary diffing is the fastest and simple one. It will only work on files with the same size and will no detect delta offsets. This is obviously not useful for all the cases, but it will help when analyzing big files or patched ones to be able to identify and extract the patched bytes.

\c $ radiff -b a.bin b.bin

\H{bindiff} Diffing with delta support

A better fine grained approach for the binary diffing should be able to detect binary changes with delta offsets.

This kind of diffing is the same algorithm used by the GNU diff utility applied on text based files. The fast hacky approach in radare is done by exporting two binaries files as one hexpair per line ascii files, and then use the GNU diff with these two files to get the delta calculations.

This is the default bindiffing engine use by radiff. You can force the use of this with '-d'.

\c radiff -d /bin/true /bin/false

The other approach is done in C++ with better performance and can be used by appending the '-e' flag.

\c radiff -e /bin/true /bin/false

\H{codediff} Diffing code graphs

Each code graph generated by the code analysis engine of radare can be stored in memory or disk using the 'R' command of radare.

\c [0xB7F73810]> R?
\c Usage: R[?] [argument] (TODO)
\c   R              ; list all RDBs loded in memory
\c   R [rdb-file]   ; load rdb file into memory
\c   R -[idx]       ; removes an rdb indexed
\c   Rm [range]     ; performs a merge between selected rdbs
\c   RG [num]       ; graph RDB number 'num'
\c   Rd [a] [b]     ; rdb diff. should generate a new rdb

in the same way it is possible to look for the differences between two different graph analysis of code by using the 'rdb diff' functionality of 'radiff -r' from the shell against two files generated by radare representing the graph structures or internally inside radare with the 'Rd' command.

This command will show the differences between these two graphs like new basic blocks, new edges, differences at byte level of the basic blocks to identify modified branches or so.

To export an RDB file from IDA use the 'ida2rdb.idc' script that lives in the documentation directory of radare.

\C{debugging} Debugger

The debugger in radare is implemented as an IO plugin. It handles two different URIs for creating or attaching to a process: dbg:// and pid://.

There are different backends for multiple architectures and operating systems like GNU/Linux, Windows, MacOSX, (Net,Free,Open)BSD and Solaris.

The process memory is interpreted by radare as a plain file. So all the mapped pages like the program and the libraries can be readed and interpreted as code, structures, etc..

The rest of the communication between radare and the debugger layer is the wrapped system() call that receives a string as argument and executes the given command. The result of the operation is buffered in the output console and this contents can be handled by a scripting language.

This is the reason why radare can handle single and double exclamation marks for calling system().

\c [0x00000000]> !step
\c [0x00000000]> !!ls

The double exclamation mark tells radare to skip the plugin list to find an IO plugin handling this command to launch it directly to the shell. A single one will walk thru the io plugin list.

The debugger commands are mostly portable between architectures and operating systems. But radare tries to implement them on all the artchitectures and OSs injecting shellcodes, or handling exceptions in a special way. For example in mips there's no stepping feature by hardware, so radare has an own implementation using a mix of code analysis and software breakpoints to bypass this limitation.

To get the basic help of the debugger you can just type '!help':

\c [0x4A13B8C0]> !help
\c  Information
\c   info               show debugger and process status
\c   msg                show last debugger status message
\c   pid [tid] [action] show pid of the debug process, current tid and childs, or set tid.
\c   status             show the contents of /proc/pid/status
\c   signal             show signals handler
\c   maps[*]            flags the current memory maps (.!rsc maps)
\c   syms               flags all syms of the debugged program (TODO: get syms from libs too)
\c   fd[?][-#] [arg]    file descriptors (fd? for help)
\c   th[?]              threads control command
\c  Stack analysis
\c   bt                 backtrace stack frames (use :!bt for user code only)
\c   st                 analyze stack trace (experimental)
\c  Memory allocation
\c   alloc [N]          allocates N bytes (no args = list regions)
\c   mmap [F] [off]     mmaps a file into a memory region
\c   free               free allocated memory regions
\c   imap               map input stream to a memory region (DEPRECATED)
\c  Loader
\c   run [args]         load and start execution
\c   (un)load           load or unload a program to debug
\c   kill [-S] [pid]    sends a signal to a process
\c   {a,de}ttach [pid]  attach or detach target pid
\c  Flow Control
\c   jmp [addr]         set program counter
\c   call [addr]        enters a subroutine
\c   ret                emulates a return from subroutine
\c   skip [N]           skip (N=1) instruction(s)
\c   step{o,u,bp,ret}   step, step over, step until user code, step until ret
\c   cont{u,uh,sc,fork} continue until user code, here, syscall or fork
\c  Tracing
\c   trace [N]          trace until bp or eof at N debug level
\c   tt [size]          touch trace using a swapable bps area
\c   wtrace             watchpoint trace (see !wp command)
\c   wp[m|?] [expr]     put a watchpoint (!wp? for help) (wpm for monitor)
\c  Breakpoints
\c   bp [addr]          put a breakpoint at addr (no arg = list)
\c   mp [rwx] [a] [s]   change memory protections at [a]ddress with [s]ize
\c   ie [-][event]      ignore debug events
\c  Registers
\c   [o|d|fp]regs[*]    show registers (o=old, d=diff, fp=fpu, *=radare)
\c   reg[s|*] [reg[=v]  show get and set registers
\c   oregs[*]           show old registers information (* for radare)
\c   dr[rwx-]           DR registers control (dr? for help) (x86 only)
\c  Other
\c   dump/restore [N]   dump/restore pages (and registers) to/from disk
\c   dall               dump from current seek to cfg.limit all available bytes (no !maps required)
\c   core               dump core of the process
\c   hack [N]           Make a hack.
\c   inject [bin]       inject code inside child process (UNSTABLE)
\c Usage: !<cmd>[?] <args> @ <offset>     ; see eval dbg. fmi

\H{regs} Registers

The registers are part of the user area stored in the context structure used by the scheduler. This structure can be manipulated to get and set values for those registers, and on intel for example, is possible to directly manipulate the DRx hardware registers to setup hardware breakpoints and watchpoints.

There are different commands to get values of the registers. For the General Purpose ones use:

\c [0x4A13B8C0]> !regs
\c   eax  0x00000000    esi  0x00000000    eip    0x4a13b8c0
\c   ebx  0x00000000    edi  0x00000000    oeax   0x0000000b
\c   ecx  0x00000000    esp  0xbfac9bd0    eflags 0x200286  
\c   edx  0x00000000    ebp  0x00000000    cPazStIdor0 (PSI)

The !reg command can be used in different ways:

\c [0x4A13B8C0]> !reg eip         ; get value of 'eip'
\c 0x4a13b8c0
\c
\c [0x4A13B8C0]> !reg eip = esp   ; set 'eip' as esp

The interaction between the plugin and the core is done by commands returning radare instructions. This is used for example to set some flags in the core to set the values of the registers.

\c [0x4A13B8C0]> !reg*    ; Appending '*' will show radare commands
\c fs regs
\c f oeax @ 0xb
\c f eax @ 0x0
\c f ebx @ 0x0
\c f ecx @ 0x0
\c f edx @ 0x0
\c f ebp @ 0x0
\c f esi @ 0x0
\c f edi @ 0x0
\c f oeip @ 0x0
\c f eip @ 0x4a13b8c0
\c f oesp @ 0x0
\c f esp @ 0xbfac9bd0
\c 
\c [0x4A13B8C0]> .!reg*  ; '.!' interprets the output of this command

Note that the 'oeax' stores the original eax value before executing a syscall. This is used by '!contsc' to identify the call, similar to 'strace'.

An old copy of the registers is stored all the time to keep track of the changes done during the execution of the program. This old copy can be accessed with '!oregs'.

\c [0x4A13B8C0]> !oregs
\c Mon, 01 Sep 2008 00:22:32 GMT
\c   eax  0x00000000    esi  0x00000000    eip    0x4a13b8c0
\c   ebx  0x00000000    edi  0x00000000    oeax   0x0000000b
\c   ecx  0x00000000    esp  0xbfac9bd0    eflags 0x200386  
\c   edx  0x00000000    ebp  0x00000000    cPazSTIdor0 (PSTI)
\c [0x4A13B8C0]> !regs
\c   eax  0xbfac9bd0    esi  0x00000000    eip    0x4a13b8c2
\c   ebx  0x00000000    edi  0x00000000    oeax   0xffffffff
\c   ecx  0x00000000    esp  0xbfac9bd0    eflags 0x200386  
\c   edx  0x00000000    ebp  0x00000000    cPazSTIdor0 (PSTI)

The values in eax, oeax and eip has changed. And this is noted when enabling scr.color.

You can easily get a string representing the last changes in the registers using the 'dregs' command (diff registers):

\c [0x4A13B8C0]> !dregs
\c eax = 0xbfac9bd0 (0x00000000)

eip register is ignored and oeax is not handled for obvious reasons :)

There's an eval variable called 'trace.cmtregs' that adds a comment after each executed instruction giving information about the changes in the registers. Here's an example

\c [0x4A13C000]> !step 5
\c [0x4A13C000]> pd 5
\c    ; 10 esp = 0xbfac9bc8 (0xbfac9bd0)  
\c    0x4A13C000,           55              push ebp            
\c    ; 12 ebp = 0xbfac9bc8 (0x00000000) esp = 0xbfac9bc8 (0xbfac9bcc)  
\c    0x4A13C001            89e5            mov ebp, esp        
\c    ; 14 ebp = 0xbfac9bc8 (0x00000000) esp = 0xbfac9bc4 (0xbfac9bc8)  
\c    0x4A13C003            57              push edi            
\c    ; 16 esp = 0xbfac9bc0 (0xbfac9bc8)  
\c    0x4A13C004,           56              push esi            
\c    ; 18 esp = 0xbfac9bbc (0xbfac9bc4)  
\c    0x4A13C005      oeip: 53              push ebx            
\c [0x4A13C000]> 

You can align these comments with 'eval asm.cmtmargin'.

The extended or floating point registers are accessed with the '!fpregs' command.

\c [0x4A13C000]> !fpregs
\c  cwd = 0x037f  ; control    swd = 0x0000  ; status
\c  twd = 0x0000  ; tag        fip = 0x0000  ; eip of fpu opcode
\c  fcs = 0x0000               foo = 0x0000  ; stack
\c  fos = 0x0000
\c  mm0 = 0000 0000 0000 0000     st0 = 0 (0x00000000)
\c  mm1 = 0000 0000 0000 0000     st1 = 0 (0x00000000)
\c  mm2 = 0000 0000 0000 0000     st2 = 0 (0x00000000)
\c  mm3 = 0000 0000 0000 0000     st3 = 0 (0x00000000)
\c  mm4 = 0000 0000 0000 0000     st4 = 0 (0x00000000)
\c  mm5 = 0000 0000 0000 0000     st5 = 0 (0x00000000)
\c  mm6 = 0000 0000 0000 0000     st6 = 0 (0x00000000)
\c  mm7 = 0000 0000 0000 0000     st7 = 0 (0x00000000)

\H{hwregs} Hardware registers

The hardware registers are only supported on few architectures. In this case only 'intel' 32 and 64 bits. also called 'DRx' on intel.

Radare allows you to manipulate them manually to setup 4 different breakpoints when reading, writing or executing (rwx):

\c [0x4A13C000]> !dr
\c DR0 0x00000000 x
\c DR1 0x00000000 x
\c DR2 0x00000000 x
\c DR3 0x00000000 x
\c [0x4A13C000]> !dr?
\c Usage: !dr[type] [args]
\c   dr                   - show DR registers
\c   dr-                  - reset DR registers
\c   drr [addr]           - set a read watchpoint
\c   drw [addr]           - set a write watchpoint
\c   drx [addr]           - set an execution watchpoint
\c   dr[0-3][rwx] [addr]  - set a rwx wp at a certain DR reg
\c Use addr=0 to undefine a DR watchpoint

For example. To setup a read exception at address 0xBF894404:

\c [0x80480303]> !dr0r 0xBF894404

The DR index can be ignored, because it can be automatically handled by radare in the same way:

\c [0x80480303]> !dr 0xBF894404

To remove all the values of the hw regs just type:

\c [0x80480303]> !dr-

\H{memprot} Memory protections

Another way to setup read/write exceptions is done by changing the protection properties of the memory pages of a program.

These properties must have an aligned size like 4096 bytes or so. This depends on the operating system and the cpu, but it is supported by all the architectures with MMU.

\c [0x4A13C000]> !mp?
\c Usage: !mp [rwx] [addr] [size]
\c   > !mp       - lists all memory protection changes
\c   > !mp --- 0x8048100 4096
\c   > !mp rwx 0x8048100 4096
\c - addr and size are aligned to memory (-=%4).

Using '!maps' you can get a list of all the mapped regions of the program, but this ones will not refer to the changes done by this command, because they are handled submappings and not all OS allows you a fine-grained control over this.

For this reason, radare handles a list of changes done by this command to allow you to reset the changes done.

Here's an example... you are interested on getting the point where a program tries to write in a buffer at a certain address. The way to catch this is by changing the properties of this page, dropping the write permission and kepping the read one.

\c [0x4A13C000]> !mp r-- 0x8054180 4096
\c [0x4A13C000]> !cont
\c
\c .. write exception ..
\c
\c [0x4A13C000]> !mp rw- 0x8054180 4096 ; restore change

\H{mmap} Memory pages

You can control different operations over the memory pages of the target process. This is an important task that should be handled by the debugger layer to get information to get the ranges of memory mapped.

The '!maps' command will list all the regions mapped in the target process. For example:

\c [0x4A13B8C0]> !maps
\c 0xbfe15000 - 0xbfe2a000 rw-- 0x00015000 [stack]
\c 0xb7f87000 - 0xb7f88000 r-x- 0x00001000 [vdso]
\c 0x4a155000 - 0x4a157000 rw-- 0x00002000 /lib/ld-2.5.so
\c 0x4a13b000 * 0x4a155000 r-x- 0x0001a000 /lib/ld-2.5.so
\c 0x0805c000 - 0x0805d000 rw-u 0x00001000 /bin/ls
\c 0x08048000 - 0x0805c000 r-xu 0x00014000 /bin/ls

The columns are start address, end address, permissions, size and name of region. At the same time all the proper flags are registered in the core named as 'section_foo' and 'section_foo_end'.

This way it is possible to iterate in scripts from these ranges easily. The '*' between the from-to addresses allows you to easily view where you are located

\c -- analyze a section
\c function opcleaner_section(name)
\c   print("FROM: "..r.get("section_"..name))
\c   from = r.get("section_"..name)
\c   to   = r.get("section_"..name.."_end")
\c   old_opcode = '' 
\c 
\c   print (string.format("Segment "..name.." at 0x%x",from))
\c 
\c   --- ... do the job here ...
\c end

So we can now work on a single segment just giving the section name:

\c opcleaner_section ("_text")

We can locate the current seek in the maps by typing '!maps?':

\c [0x4A13B8C0]> !maps?
\c 0x4a13b000 * 0x4a155000 r-x- 0x0001a000 /lib/ld-2.5.so

\H{mem-dump} Dumping memory

There are different commands to dump these sections to disk. The '!dump' and '!restore' are used to create a directory called 'dump#' where '#' is a number starting from 0 and is incremented while called multiple times. So you can use '!dump' and '!restore' to go 'forward' and 'backward' of the process status. Because it is also dumping and restoring the register values.

\c [0x4A13B8C0]> !dump
\c Dump directory: dump0
\c Dumping BFE15000-BFE2A000.dump  ; 0x00015000  [stack]
\c Dumping 4A155000-4A157000.dump  ; 0x00002000  /lib/ld-2.5.so
\c Dumping 0805C000-0805D000.dump  ; 0x00001000  /bin/ls
\c Dumping 08048000-0805C000.dump  ; 0x00014000  /bin/ls
\c Dumping CPU to cpustate.dump...

You can also specify the directory name as argument:

\c [0x4A13B8C0]> !dump foo
\c ...
\c [0x4A13B8C0]> !restore foo

The '!dall' command is similar to the previous one, but it is based on the concept that there are no maps sections information. This is useful on some unixes like some BSDs that they have no /proc to get this information. So it reads from 0 to 0xFFFFFFFF looking for readables pages and dumping them to files named 'from-to.bin' in the current directory.

\H{mem-management} Managing memory

It is also possible to allocate and free new memory regions on the child process at specified or decided by the system. In the following example we are allocating 10 MB in the child process.

\c [0x000000C0]> !alloc 10M
\c 0xb7587000
\c [0x000000C0]> s 0xb7587000
\c [0xB7587000]> x
\c    offset   0 1  2 3  4 5  6 7  8 9  A B  C D  0123456789ABCD
\c 0xB7587000, 0000 0000 0000 0000 0000 0000 0000 ..............
\c 0xB758700E  0000 0000 0000 0000 0000 0000 0000 ..............

We can now write the contents of a file here:

\c [0xb7587000]> wf program.bin

But there's another option for mapping files in memory: '!mmap':

XXX: this is not working

In the same way you can create a core file with '!core'. But this is currently system-specific.

\H{exec} Run control

The basic life-cycle of a process can be managed with different commands of the debugger.

\c !load         ; reload the process (restart program)
\c !run          ; start running

\c !step         ; executes a single instruction
\c !stepo        ; step over call instructions
\c !stepret      ; step instructions until function return
\c !stepu [addr] ; step until address
\c !stepbp       ; step using breakpoints and code analysis

Is interesting to have multiple ways to perform stepping and continuation to be able to bypass different protections like avoid changing the memory adding software breakpoints, just stepping until an address.

You can also step N times in two ways:

\c [0x80484040]> !step 4
\c [0x80484040]> 4!step

About continuations radare offers multiple commands for handling process continuations:

\c !cont         ; continue execution
\c !contu [addr] ; continue until address using a breakpoint
\c !contuh       ; continue until here
\c !contsc       ; continue until syscall (strace)
\c !contfork     ; continue until new child is created

The 'contuh' command is quite useful when analyzing loops, because allows you to easily complete a loop without having to manually setup breakpoints.

\H{tt} Touch Tracing

The 'touch trace' is a special tracing engine that was born from an idea of Gadix (Thanks! ;D)

The main idea of '!tt' (which is the assigned command name for this feature) is to fill N bytes of the process memory with software breakpoints while the debugger keeps a copy of the original bytes.

When a breakpoint not swapped by the debugger is catched between this memory range the debugger swaps the original bytes into the process memory and continues the execution. When the program counter stops outside this range, the program memory of the traced program is restored and the debugger keeps the tracing information accessible with the 'at' command explained in another chapter.

In this way it is possible to create a fast trace, so each instruction will only be tracked one time. So you will be able to generate multiple traces of different parts of the program without a high cpu load and allowing you to easily identify the executed regions of a program with a decent user interaction.

To use this command just give an argument with the size of the tracing area to be swapped and the program will start running

\c [0xB7F75810]> !tt 10K
\c [0xB7F75810]> at
\c 0xb7f75810 - 0xb7f7585a
\c 0xb7f75860 - 0xb7f75876
\c 0xb7f75a60 - 0xb7f75b8b
\c 0xb7f75b95 - 0xb7f75b9f
\c ...

\H{bps} Breakpoints

TODO: software/hardware

\H{wps} Watchpoints

\H{fds} Filedescriptors

The file descriptors of a process can be manipulated in multiple ways to get information about the opened files of a program, in which permissions, duplicate them as new file descriptors, close, change the seek, open a file on an already opened filedescriptor or making a TCP connection for example.

All this stuff is system-dependant, so if it is not implemented in your favourite operating system(R) i'll be happy to receive feedback and patches.

It is handled by the '!fd' command:

\c [0x4A13C00E]> !fd?
\c Usage: !fd[s|d] [-#] [file | host:port]
\c   !fd                   ; list filedescriptors
\c   !fdd 2 7              ; dup2(2, 7)
\c   !fds 3 0x840          ; seek filedescriptor
\c   !fd -1                ; close stdout
\c   !fd /etc/motd         ; open file at fd=3
\c   !fd 127.0.0.1:9999    ; open socket at fd=5

Here's the filedescriptor list once a process is created with stdin, stdout and sterr

[0x4A13C00E]> !fd
 0 0x00000013 rwC /dev/pts/0
 1 0x00000000 rwC /dev/pts/0
 2 0x00000000 rwC /dev/pts/0

Now we can close the stdout of the program or just redirect them to a file opening a file on the fd number '1':

\c [0x4A13C00E]> !fd /tmp/stdout.txt  ; open new fd
\c [0x4A13C00E]> !fd -1               ; close stdout
\c [0x4A13C00E]> !fdd 3 1             ; stdout = new_fd
\c [0x4A13C00E]> !fd -3               ; close file

\H{thprocs} Threads and processes

The list of child processes of the target process can be listed with '!pid' command.

\c $ radare -d /bin/sh
\c 
\c [0x13B8C0]> !run
\c To cleanly stop the execution, type: "^Z kill -STOP 1527 && fg"
\c
\c sh-3.2$ ls
\c pid: 1611. new process created!
\c  - Use !pid for processes, and !th for threads
\c CLONE HAS BEEN INVOKED
\c debug_dispatch_wait: RET = 0 WS(event)=6 INT3_EVENT=2 INT_EVENT=3 CLONE_EVENT=6
\c === cont: tid: 1611 event: 6, signal: 19 (SIGSTOP). stop at 0x4ab95eb3
\c 
\c [0x4A13B8C0]> !pid
\c  pid : 1527 0x4ab95eb3 (stopped)
\c  pid : 1611 0x4ab95eb3 (stopped)
\c  `- 1611 : /bin/sh (stopped)

The /bin/sh while calling 'ls'. This event has been catched by radare and prompts you again. Now we can choose which process we want to follow. The parent or the child.

\c [0x4A13B8C0]> !pid 1527
\c Current selected thread id (pid): 1527

The same operations can be done by using the '!th' command for the threads.

In the same way you can hackily 'attach' and 'detach' from to a pid.

\H{dbg-events} Event handling

It is possible to configure which events should be ignored by the debugger

\c [0x4A13B8C0]> !ie
\c  0 stop
\c  0 trap
\c  0 pipe
\c  0 alarm
\c  0 fpe
\c  0 ill
\c 
\c [0x4A13B8C0]> !ie stop
\c [0x4A13B8C0]> !ie | grep stop
\c  1 stop

The 'ie' command refers to 'ignore events'

\H{dbg-signal} Signal handling

You can change visualize and change the signal handlers of the target process:

\c [0x4A13B8C0]> !signal
\c SIGHUP     (DEFAULT)
\c SIGINT     (IGNORE)
\c SIGQUIT    (DEFAULT)
\c SIGILL     (DEFAULT)
\c SIGTRAP    (DEFAULT)
\c SIGABRT    (DEFAULT)
\c SIGFPE     (DEFAULT)
\c SIGKILL    (DEFAULT)
\c SIGBUS     (DEFAULT)
\c SIGSEGV    (DEFAULT)
\c SIGSYS     (DEFAULT)
\c SIGPIPE    (DEFAULT)
\c SIGALRM    (IGNORE)
\c SIGTERM    (DEFAULT)
\c SIGURG     (DEFAULT)
\c SIGSTOP    (DEFAULT)
\c SIGTSTP    (DEFAULT)
\c SIGCONT    (DEFAULT)
\c SIGCHLD    (DEFAULT)
\c SIGTTIN    (DEFAULT)
\c SIGTTOU    (DEFAULT)
\c SIGIO      (DEFAULT)

\c [0xB7FA8810]> !sig SIGIO 0x8049350
\c Signal 29 handled by 0x08049350
\c [0xB7FA8810]> !sig SIGIO
\c SIGIO      (0x8049350)
\c [0xB7FA8810]> !sig SIGIO 0
\c (DEFAULT)
\c [0xB7FA8810]> !sig SIGIO
\c SIGIO      (DEFAULT)
\c [0xB7FA8810]> 

\H{events} Events

You can even configure radare to handle or ignore multiple types of events. This is useful to avoid stopping when an event is received from the child process.

\c [0xB7FA8810]> !ie?
\c Usage: !ie [-]<event>
\c  - enables or disables the 'ignore event' 
\c [0xB7FA8810]> !ie
\c  0 stop
\c  0 trap
\c  0 pipe
\c  0 alarm
\c  0 fpe
\c  0 ill

This is usually used to bypass some packer protections that relay on some events. So this way you can skip them just with '!ie stop' or '!ie -stop'.

\C{script} Scripting

TODO

\C{graph} Graphing code and data

'ag' command'
'ad' command'
TODO

\C{greetings} Greetings

I would like to greet some drugs, drinks and people that shared his life with mine during the development of radare and this book.

\u - God. aka Flying Spaguetti Monster

\u - Laia

\u - nopcode guys

\u - Sexy Pandas

\u - Gerardo

\u - Esteve

\u - Nibble
