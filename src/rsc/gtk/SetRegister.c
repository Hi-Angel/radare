/* SetRegister.c generated by valac, the Vala compiler
 * generated from SetRegister.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>


#define TYPE_SET_REGISTER (set_register_get_type ())
#define SET_REGISTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SET_REGISTER, SetRegister))
#define SET_REGISTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SET_REGISTER, SetRegisterClass))
#define IS_SET_REGISTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SET_REGISTER))
#define IS_SET_REGISTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SET_REGISTER))
#define SET_REGISTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SET_REGISTER, SetRegisterClass))

typedef struct _SetRegister SetRegister;
typedef struct _SetRegisterClass SetRegisterClass;
typedef struct _SetRegisterPrivate SetRegisterPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define __g_list_free_g_free0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_free (var), NULL)))

struct _SetRegister {
	GtkDialog parent_instance;
	SetRegisterPrivate * priv;
};

struct _SetRegisterClass {
	GtkDialogClass parent_class;
};

struct _SetRegisterPrivate {
	GtkComboBoxEntry* cbe;
	GtkEntry* regvalue;
	char* regname;
	GHashTable* regs;
};


static gpointer set_register_parent_class = NULL;

GType set_register_get_type (void);
#define SET_REGISTER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SET_REGISTER, SetRegisterPrivate))
enum  {
	SET_REGISTER_DUMMY_PROPERTY
};
SetRegister* set_register_new (void);
SetRegister* set_register_construct (GType object_type);
static void set_register_init_regs (SetRegister* self);
static void _g_list_free_g_free (GList* self);
static void set_register_fill_comboboxentry (SetRegister* self);
static char* set_register_get_reg_value (SetRegister* self);
static void set_register_on_combobox_changed (SetRegister* self);
static void set_register_ok_clicked (SetRegister* self);
static void set_register_on_response (SetRegister* self, GtkDialog* source, gint response_id);
static gint set_register_main (char** args, int args_length1);
static void _set_register_on_response_gtk_dialog_response (SetRegister* _sender, gint response_id, gpointer self);
static void _gtk_main_quit_gtk_object_destroy (SetRegister* _sender, gpointer self);
static void _lambda0_ (GtkComboBoxEntry* target, SetRegister* self);
static void __lambda0__gtk_combo_box_changed (GtkComboBoxEntry* _sender, gpointer self);
static GObject * set_register_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void set_register_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);



SetRegister* set_register_construct (GType object_type) {
	SetRegister * self;
	self = g_object_newv (object_type, 0, NULL);
	gtk_dialog_add_button ((GtkDialog*) self, GTK_STOCK_CANCEL, (gint) GTK_RESPONSE_CANCEL);
	gtk_dialog_add_button ((GtkDialog*) self, GTK_STOCK_OK, (gint) GTK_RESPONSE_OK);
	return self;
}


SetRegister* set_register_new (void) {
	return set_register_construct (TYPE_SET_REGISTER);
}


static char* string_substring (const char* self, glong offset, glong len) {
	char* result;
	glong string_length;
	const char* start;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = g_utf8_strlen (self, -1);
	if (offset < 0) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= 0, NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < 0) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	start = g_utf8_offset_to_pointer (self, offset);
	result = g_strndup (start, ((gchar*) g_utf8_offset_to_pointer (start, len)) - ((gchar*) start));
	return result;
}


static void set_register_init_regs (SetRegister* self) {
	GError * _inner_error_;
	GHashTable* _tmp0_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	self->priv->regs = (_tmp0_ = g_hash_table_new (g_str_hash, g_str_equal), _g_hash_table_unref0 (self->priv->regs), _tmp0_);
	{
		GFile* file;
		GFileInputStream* _tmp1_;
		GFileInputStream* _tmp2_;
		GDataInputStream* _tmp3_;
		GDataInputStream* in_stream;
		char* line;
		file = g_file_new_for_path ("/tmp/.regs");
		_tmp1_ = g_file_read (file, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (file);
			goto __catch0_g_error;
			goto __finally0;
		}
		in_stream = (_tmp3_ = g_data_input_stream_new ((GInputStream*) (_tmp2_ = _tmp1_)), _g_object_unref0 (_tmp2_), _tmp3_);
		line = NULL;
		while (TRUE) {
			const char* _tmp4_;
			char* _tmp5_;
			char** _tmp9_;
			gint arr_size;
			gint arr_length1;
			char** _tmp7_;
			char* _tmp6_;
			char** _tmp8_;
			char** arr;
			_tmp4_ = g_data_input_stream_read_line (in_stream, NULL, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (file);
				_g_object_unref0 (in_stream);
				_g_free0 (line);
				goto __catch0_g_error;
				goto __finally0;
			}
			if (!((line = (_tmp5_ = g_strdup (_tmp4_), _g_free0 (line), _tmp5_)) != NULL)) {
				break;
			}
			arr = (_tmp9_ = (_tmp8_ = _tmp7_ = g_regex_split_simple (" @ ", _tmp6_ = string_substring (line, (glong) 2, (glong) (-1)), 0, 0), _g_free0 (_tmp6_), _tmp8_), arr_length1 = _vala_array_length (_tmp7_), arr_size = arr_length1, _tmp9_);
			if (arr_length1 < 2) {
				arr = (_vala_array_free (arr, arr_length1, (GDestroyNotify) g_free), NULL);
				break;
			}
			g_hash_table_insert (self->priv->regs, g_strdup (arr[0]), g_strdup (arr[1]));
			arr = (_vala_array_free (arr, arr_length1, (GDestroyNotify) g_free), NULL);
		}
		_g_object_unref0 (file);
		_g_object_unref0 (in_stream);
		_g_free0 (line);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "Error: %s\n", e->message);
			fprintf (stderr, "File: '/tmp/.regs'!\n");
			_g_error_free0 (e);
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void _g_list_free_g_free (GList* self) {
	g_list_foreach (self, (GFunc) g_free, NULL);
	g_list_free (self);
}


static void set_register_fill_comboboxentry (SetRegister* self) {
	GList* list;
	g_return_if_fail (self != NULL);
	list = NULL;
	{
		GList* reg_collection;
		GList* reg_it;
		reg_collection = g_hash_table_get_keys (self->priv->regs);
		for (reg_it = reg_collection; reg_it != NULL; reg_it = reg_it->next) {
			char* reg;
			reg = g_strdup ((const char*) reg_it->data);
			{
				list = g_list_append (list, g_strdup (reg));
				_g_free0 (reg);
			}
		}
		_g_list_free0 (reg_collection);
	}
	list = g_list_sort (list, strcmp);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < g_list_length (list))) {
					break;
				}
				gtk_combo_box_append_text ((GtkComboBox*) self->priv->cbe, (const char*) g_list_nth_data (list, (guint) i));
			}
		}
	}
	__g_list_free_g_free0 (list);
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, -1);
	return result;
}


static void set_register_on_combobox_changed (SetRegister* self) {
	char* _tmp0_;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	self->priv->regname = (_tmp0_ = g_strdup (gtk_combo_box_get_active_text ((GtkComboBox*) self->priv->cbe)), _g_free0 (self->priv->regname), _tmp0_);
	if (string_get_length (self->priv->regname) > 2) {
		char* _tmp2_;
		_tmp1_ = (_tmp2_ = set_register_get_reg_value (self)) != NULL;
		_g_free0 (_tmp2_);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		char* _tmp3_;
		gtk_entry_set_text (self->priv->regvalue, _tmp3_ = set_register_get_reg_value (self));
		_g_free0 (_tmp3_);
	}
}


static char* set_register_get_reg_value (SetRegister* self) {
	char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = g_strdup ((const char*) g_hash_table_lookup (self->priv->regs, self->priv->regname));
	return result;
}


static void set_register_on_response (SetRegister* self, GtkDialog* source, gint response_id) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	switch (response_id) {
		case GTK_RESPONSE_CANCEL:
		{
			gtk_object_destroy ((GtkObject*) self);
			break;
		}
		case GTK_RESPONSE_OK:
		{
			set_register_ok_clicked (self);
			gtk_object_destroy ((GtkObject*) self);
			break;
		}
	}
}


static void set_register_ok_clicked (SetRegister* self) {
	g_return_if_fail (self != NULL);
	fprintf (stdout, ":!reg %s=%s\n", self->priv->regname, gtk_entry_get_text (self->priv->regvalue));
}


static gint set_register_main (char** args, int args_length1) {
	gint result;
	SetRegister* dialog;
	gtk_init (&args_length1, &args);
	dialog = g_object_ref_sink (set_register_new ());
	gtk_widget_show_all ((GtkWidget*) dialog);
	set_register_init_regs (dialog);
	set_register_fill_comboboxentry (dialog);
	gtk_main ();
	result = 0;
	_g_object_unref0 (dialog);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return set_register_main (argv, argc);
}


static void _set_register_on_response_gtk_dialog_response (SetRegister* _sender, gint response_id, gpointer self) {
	set_register_on_response (self, _sender, response_id);
}


static void _gtk_main_quit_gtk_object_destroy (SetRegister* _sender, gpointer self) {
	gtk_main_quit ();
}


static void _lambda0_ (GtkComboBoxEntry* target, SetRegister* self) {
	g_return_if_fail (target != NULL);
	set_register_on_combobox_changed (self);
}


static void __lambda0__gtk_combo_box_changed (GtkComboBoxEntry* _sender, gpointer self) {
	_lambda0_ (_sender, self);
}


static GObject * set_register_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SetRegister * self;
	parent_class = G_OBJECT_CLASS (set_register_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = SET_REGISTER (obj);
	{
		GtkHBox* _hbox0;
		GtkLabel* _label0;
		GtkHBox* _hbox1;
		GtkLabel* _label1;
		GtkHBox* _tmp0_;
		GtkLabel* _tmp1_;
		GtkComboBoxEntry* _tmp2_;
		GtkHBox* _tmp3_;
		GtkLabel* _tmp4_;
		GtkEntry* _tmp5_;
		GtkVBox* _tmp6_;
		GtkVBox* _tmp7_;
		GtkVBox* _tmp8_;
		_hbox0 = NULL;
		_label0 = NULL;
		_hbox1 = NULL;
		_label1 = NULL;
		_hbox0 = (_tmp0_ = g_object_ref_sink ((GtkHBox*) gtk_hbox_new (FALSE, 10)), _g_object_unref0 (_hbox0), _tmp0_);
		_label0 = (_tmp1_ = g_object_ref_sink ((GtkLabel*) gtk_label_new_with_mnemonic ("Register:")), _g_object_unref0 (_label0), _tmp1_);
		self->priv->cbe = (_tmp2_ = g_object_ref_sink ((GtkComboBoxEntry*) gtk_combo_box_entry_new_text ()), _g_object_unref0 (self->priv->cbe), _tmp2_);
		_hbox1 = (_tmp3_ = g_object_ref_sink ((GtkHBox*) gtk_hbox_new (FALSE, 10)), _g_object_unref0 (_hbox1), _tmp3_);
		_label1 = (_tmp4_ = g_object_ref_sink ((GtkLabel*) gtk_label_new_with_mnemonic ("Value:")), _g_object_unref0 (_label1), _tmp4_);
		self->priv->regvalue = (_tmp5_ = g_object_ref_sink ((GtkEntry*) gtk_entry_new ()), _g_object_unref0 (self->priv->regvalue), _tmp5_);
		gtk_window_set_title ((GtkWindow*) self, "Set Register");
		gtk_dialog_set_has_separator ((GtkDialog*) self, FALSE);
		gtk_container_set_border_width ((GtkContainer*) self, (guint) 5);
		g_object_set ((GtkWindow*) self, "default-width", 300, NULL);
		g_object_set ((GtkWindow*) self, "default-height", 80, NULL);
		g_signal_connect_object ((GtkDialog*) self, "response", (GCallback) _set_register_on_response_gtk_dialog_response, self, 0);
		g_signal_connect ((GtkObject*) self, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
		gtk_label_set_mnemonic_widget (_label0, (GtkWidget*) self->priv->cbe);
		gtk_box_pack_start ((GtkBox*) _hbox0, (GtkWidget*) _label0, FALSE, TRUE, (guint) 0);
		g_signal_connect_object ((GtkComboBox*) self->priv->cbe, "changed", (GCallback) __lambda0__gtk_combo_box_changed, self, 0);
		gtk_container_add ((GtkContainer*) _hbox0, (GtkWidget*) self->priv->cbe);
		gtk_box_pack_start ((GtkBox*) (_tmp6_ = ((GtkDialog*) self)->vbox, GTK_IS_VBOX (_tmp6_) ? ((GtkVBox*) _tmp6_) : NULL), (GtkWidget*) _hbox0, FALSE, TRUE, (guint) 0);
		gtk_label_set_mnemonic_widget (_label1, (GtkWidget*) self->priv->regvalue);
		gtk_box_pack_start ((GtkBox*) _hbox1, (GtkWidget*) _label1, FALSE, TRUE, (guint) 0);
		gtk_container_add ((GtkContainer*) _hbox1, (GtkWidget*) self->priv->regvalue);
		gtk_box_pack_start ((GtkBox*) (_tmp7_ = ((GtkDialog*) self)->vbox, GTK_IS_VBOX (_tmp7_) ? ((GtkVBox*) _tmp7_) : NULL), (GtkWidget*) _hbox1, FALSE, TRUE, (guint) 0);
		gtk_box_set_spacing ((GtkBox*) (_tmp8_ = ((GtkDialog*) self)->vbox, GTK_IS_VBOX (_tmp8_) ? ((GtkVBox*) _tmp8_) : NULL), 10);
		_g_object_unref0 (_hbox0);
		_g_object_unref0 (_label0);
		_g_object_unref0 (_hbox1);
		_g_object_unref0 (_label1);
	}
	return obj;
}


static void set_register_class_init (SetRegisterClass * klass) {
	set_register_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SetRegisterPrivate));
	G_OBJECT_CLASS (klass)->constructor = set_register_constructor;
	G_OBJECT_CLASS (klass)->finalize = set_register_finalize;
}


static void set_register_instance_init (SetRegister * self) {
	self->priv = SET_REGISTER_GET_PRIVATE (self);
}


static void set_register_finalize (GObject* obj) {
	SetRegister * self;
	self = SET_REGISTER (obj);
	_g_object_unref0 (self->priv->cbe);
	_g_object_unref0 (self->priv->regvalue);
	_g_free0 (self->priv->regname);
	_g_hash_table_unref0 (self->priv->regs);
	G_OBJECT_CLASS (set_register_parent_class)->finalize (obj);
}


GType set_register_get_type (void) {
	static GType set_register_type_id = 0;
	if (set_register_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (SetRegisterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) set_register_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SetRegister), 0, (GInstanceInitFunc) set_register_instance_init, NULL };
		set_register_type_id = g_type_register_static (GTK_TYPE_DIALOG, "SetRegister", &g_define_type_info, 0);
	}
	return set_register_type_id;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




